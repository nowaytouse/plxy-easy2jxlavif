// media_tools - åª’ä½“æ–‡ä»¶è¾…åŠ©å·¥å…·é›†
//
// åŠŸèƒ½è¯´æ˜ï¼š
// 1. XMPå…ƒæ•°æ®åˆå¹¶ (mergeå‘½ä»¤)
// 2. é‡å¤åª’ä½“æ–‡ä»¶æ£€æµ‹å’Œæ¸…ç† (dedupå‘½ä»¤)
//
// ä½œè€…ï¼šAI Assistant
// ç‰ˆæœ¬ï¼š2.2.0
package main

import (
	"crypto/sha256"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"

	"pixly/utils"
)

// ç¨‹åºå¸¸é‡å®šä¹‰
const (
	toolName = "media_tools"  // å·¥å…·åç§°
	version  = "2.2.2"        // ç¨‹åºç‰ˆæœ¬å·
	author   = "AI Assistant" // ä½œè€…ä¿¡æ¯
)

// å…¨å±€å˜é‡å®šä¹‰
var (
	logger *log.Logger // å…¨å±€æ—¥å¿—è®°å½•å™¨
)

// å‘½ä»¤ç±»å‹
type Command string

const (
	MergeXMP  Command = "merge"     // åˆå¹¶XMPå…ƒæ•°æ®
	Dedup     Command = "dedup"     // å»é‡åª’ä½“æ–‡ä»¶
	Normalize Command = "normalize" // è§„èŒƒåŒ–æ–‡ä»¶æ‰©å±•å
	Auto      Command = "auto"      // è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œ
)

func init() {
	// è®¾ç½®æ—¥å¿—è®°å½•å™¨ï¼Œå¸¦å¤§å°è½®è½¬
	rl, lf, err := utils.NewRotatingLogger("media_tools.log", 50*1024*1024)
	if err != nil {
		log.Fatalf("æ— æ³•åˆå§‹åŒ–è½®è½¬æ—¥å¿—: %v", err)
	}
	logger = rl
	_ = lf
}

func main() {
	logger.Printf("ğŸ› ï¸  åª’ä½“å·¥å…·é›† v%s", version)
	logger.Printf("âœ¨ ä½œè€…: %s", author)

	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := Command(os.Args[1])
	switch command {
	case MergeXMP:
		runMergeXMP(os.Args[2:])
	case Dedup:
		runDedup(os.Args[2:])
	case Normalize:
		runNormalize(os.Args[2:])
	case Auto:
		runAuto(os.Args[2:])
	default:
		logger.Printf("âŒ æœªçŸ¥å‘½ä»¤: %s", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println(`
åª’ä½“å·¥å…·é›† v2.2.0

ç”¨æ³•:
  media_tools <å‘½ä»¤> [å‚æ•°]

å‘½ä»¤:
  merge      åˆå¹¶XMPä¾§è¾¹æ–‡ä»¶åˆ°åª’ä½“æ–‡ä»¶
  dedup      æ£€æµ‹å¹¶æ¸…ç†é‡å¤åª’ä½“æ–‡ä»¶
  normalize  è§„èŒƒåŒ–æ–‡ä»¶æ‰©å±•å (.jpegâ†’.jpg, .tiffâ†’.tif)
  auto       è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œï¼ˆæ¨èï¼‰

ç¤ºä¾‹:
  # è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œï¼ˆæ¨èï¼‰
  media_tools auto -dir /path/to/media -trash /path/to/trash

  # å•ç‹¬æ‰§è¡Œå„é¡¹æ“ä½œ
  media_tools merge -dir /path/to/media
  media_tools normalize -dir /path/to/media
  media_tools dedup -dir /path/to/media -trash /path/to/trash

è·å–å‘½ä»¤å¸®åŠ©:
  media_tools merge -h
  media_tools dedup -h
  media_tools normalize -h
  media_tools auto -h
`)
}

// ====== XMPåˆå¹¶åŠŸèƒ½ ======

func runMergeXMP(args []string) {
	fs := flag.NewFlagSet("merge", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½• (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹XMPå…ƒæ•°æ®åˆå¹¶...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// æ‰«æXMPæ–‡ä»¶
	xmpFiles, err := scanXMPFiles(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«æXMPæ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªXMPæ–‡ä»¶", len(xmpFiles))

	merged := 0
	failed := 0

	for _, xmpFile := range xmpFiles {
		mediaFile := findMediaFile(xmpFile)
		if mediaFile == "" {
			logger.Printf("âš ï¸  æœªæ‰¾åˆ°å¯¹åº”åª’ä½“æ–‡ä»¶: %s", xmpFile)
			failed++
			continue
		}

		if *dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†åˆå¹¶: %s -> %s", xmpFile, mediaFile)
			merged++
			continue
		}

		// æ‰§è¡Œåˆå¹¶
		if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
			logger.Printf("âŒ åˆå¹¶å¤±è´¥: %s -> %s: %v", xmpFile, mediaFile, err)
			failed++
			continue
		}

		logger.Printf("âœ… åˆå¹¶æˆåŠŸ: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))

		// åˆ é™¤å·²åˆå¹¶çš„XMPæ–‡ä»¶
		if err := os.Remove(xmpFile); err != nil {
			logger.Printf("âš ï¸  åˆ é™¤XMPæ–‡ä»¶å¤±è´¥: %s: %v", filepath.Base(xmpFile), err)
		} else {
			logger.Printf("ğŸ—‘ï¸  å·²åˆ é™¤XMPæ–‡ä»¶: %s", filepath.Base(xmpFile))
		}

		merged++
	}

	logger.Printf("ğŸ“Š åˆå¹¶å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", merged, failed)
}

// scanXMPFiles æ‰«æXMPæ–‡ä»¶
func scanXMPFiles(dir string) ([]string, error) {
	var xmpFiles []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(strings.ToLower(path), ".xmp") {
			xmpFiles = append(xmpFiles, path)
		}
		return nil
	})
	return xmpFiles, err
}

// findMediaFile æŸ¥æ‰¾å¯¹åº”çš„åª’ä½“æ–‡ä»¶
// æ”¯æŒåŒ…å«ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„
func findMediaFile(xmpFile string) string {
	// ç§»é™¤.xmpæˆ–.sidecar.xmpåç¼€
	basePath := strings.TrimSuffix(xmpFile, ".xmp")
	basePath = strings.TrimSuffix(basePath, ".sidecar")

	// å°è¯•æŸ¥æ‰¾å¯¹åº”çš„åª’ä½“æ–‡ä»¶
	mediaExts := []string{".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mov", ".avi", ".jxl", ".avif", ".heic", ".heif", ".webp", ".bmp", ".tiff", ".tif"}
	for _, ext := range mediaExts {
		mediaFile := basePath + ext
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
		// å°è¯•å¤§å†™
		mediaFile = basePath + strings.ToUpper(ext)
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
	}

	return ""
}

// mergeXMPToMedia åˆå¹¶XMPåˆ°åª’ä½“æ–‡ä»¶ï¼Œå¹¶éªŒè¯åˆå¹¶ç»“æœ
func mergeXMPToMedia(xmpFile, mediaFile string) error {
	// 1. éªŒè¯æ–‡ä»¶è·¯å¾„å®‰å…¨æ€§
	if !isValidFilePath(xmpFile) || !isValidFilePath(mediaFile) {
		return fmt.Errorf("æ–‡ä»¶è·¯å¾„åŒ…å«ä¸å®‰å…¨å­—ç¬¦")
	}

	// 2. éªŒè¯åª’ä½“æ–‡ä»¶æ‰©å±•å
	if !isMediaFile(filepath.Ext(mediaFile)) {
		return fmt.Errorf("ä¸æ”¯æŒçš„åª’ä½“æ–‡ä»¶æ ¼å¼: %s", filepath.Ext(mediaFile))
	}

	// 3. éªŒè¯XMPæ–‡ä»¶å†…å®¹
	if !isValidXMPFile(xmpFile) {
		return fmt.Errorf("XMPæ–‡ä»¶æ ¼å¼æ— æ•ˆ")
	}

	// 4. æ‰§è¡Œåˆå¹¶
	cmd := exec.Command("exiftool", "-overwrite_original", "-TagsFromFile", xmpFile, "-all:all", mediaFile)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("exiftoolæ‰§è¡Œå¤±è´¥: %v\nè¾“å‡º: %s", err, string(output))
	}

	// 5. éªŒè¯åˆå¹¶ç»“æœ
	if !verifyMerge(mediaFile, xmpFile) {
		return fmt.Errorf("åˆå¹¶éªŒè¯å¤±è´¥")
	}

	return nil
}

// isValidFilePath éªŒè¯æ–‡ä»¶è·¯å¾„æ˜¯å¦å®‰å…¨
func isValidFilePath(filePath string) bool {
	// æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
	if strings.ContainsAny(filePath, "\x00") {
		return false
	}

	// æ£€æŸ¥è·¯å¾„é•¿åº¦
	if len(filePath) > 4096 {
		return false
	}

	return true
}

// isMediaFile æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦ä¸ºæ”¯æŒçš„åª’ä½“æ ¼å¼
func isMediaFile(ext string) bool {
	switch strings.ToLower(ext) {
	case ".jpg", ".jpeg", ".png", ".tif", ".tiff", ".gif", ".mp4", ".mov", ".heic", ".heif", ".webp", ".avif", ".jxl", ".avi", ".mkv", ".bmp", ".psd", ".psb", ".cr2", ".cr3", ".nef", ".arw", ".dng", ".raf", ".orf", ".rw2":
		return true
	default:
		return false
	}
}

// isValidXMPFile éªŒè¯XMPæ–‡ä»¶æ ¼å¼æ˜¯å¦æœ‰æ•ˆ
func isValidXMPFile(xmpPath string) bool {
	file, err := os.Open(xmpPath)
	if err != nil {
		return false
	}
	defer file.Close()

	// è¯»å–æ–‡ä»¶å¤´æ£€æŸ¥XMPæ ¼å¼
	header := make([]byte, 100)
	n, err := file.Read(header)
	if err != nil || n < 10 {
		return false
	}

	// æ£€æŸ¥æ˜¯å¦åŒ…å«XMPæ ‡è¯†
	content := string(header)
	if !strings.Contains(content, "xmpmeta") && !strings.Contains(content, "XMP") && !strings.Contains(content, "x:xmpmeta") {
		return false
	}

	// æ£€æŸ¥æ–‡ä»¶å¤§å°æ˜¯å¦åˆç†ï¼ˆXMPæ–‡ä»¶é€šå¸¸ä¸ä¼šå¤ªå¤§ï¼‰
	stat, err := file.Stat()
	if err != nil {
		return false
	}

	// XMPæ–‡ä»¶å¤§å°åº”è¯¥åœ¨100å­—èŠ‚åˆ°10MBä¹‹é—´
	if stat.Size() < 100 || stat.Size() > 10*1024*1024 {
		return false
	}

	return true
}

// verifyMerge éªŒè¯XMPåˆå¹¶æ˜¯å¦æˆåŠŸ
// é€šè¿‡æ¯”è¾ƒXMPæ–‡ä»¶ä¸­çš„å…³é”®æ ‡ç­¾ä¸åª’ä½“æ–‡ä»¶ä¸­çš„æ ‡ç­¾æ¥éªŒè¯
func verifyMerge(mediaPath, xmpPath string) bool {
	// è·å–XMPæ–‡ä»¶ä¸­çš„æ‰€æœ‰æ ‡ç­¾
	xmpTagsCmd := exec.Command("exiftool", "-j", xmpPath)
	xmpTagsOutput, err := xmpTagsCmd.CombinedOutput()
	if err != nil {
		logger.Printf("âŒ è·å–XMPæ–‡ä»¶æ ‡ç­¾å¤±è´¥ %s: %v", filepath.Base(xmpPath), err)
		return false
	}

	var tags []map[string]interface{}
	if err := json.Unmarshal(xmpTagsOutput, &tags); err != nil {
		logger.Printf("âŒ è§£æXMPæ ‡ç­¾å¤±è´¥ %s: %v", filepath.Base(xmpPath), err)
		return false
	}

	if len(tags) == 0 || len(tags[0]) == 0 {
		logger.Printf("âš ï¸  XMPæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯ç”¨æ ‡ç­¾ %s", filepath.Base(xmpPath))
		return false
	}

	// æ‰¾åˆ°ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ ‡ç­¾è¿›è¡ŒéªŒè¯ï¼Œé¿å…æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„æ ‡ç­¾
	var tagToVerify string
	for tag := range tags[0] {
		if !strings.HasPrefix(tag, "File:") && tag != "SourceFile" && tag != "ExifTool:ExifToolVersion" {
			tagToVerify = tag
			break
		}
	}

	if tagToVerify == "" {
		logger.Printf("âš ï¸  æ²¡æœ‰æ‰¾åˆ°å¯éªŒè¯çš„æ ‡ç­¾ %s", filepath.Base(xmpPath))
		return false
	}

	// æ£€æŸ¥åª’ä½“æ–‡ä»¶ä¸­æ˜¯å¦å­˜åœ¨è¯¥æ ‡ç­¾
	mediaTagCmd := exec.Command("exiftool", "-"+tagToVerify, mediaPath)
	mediaTagOutput, err := mediaTagCmd.CombinedOutput()
	if err != nil {
		logger.Printf("âŒ è·å–åª’ä½“æ–‡ä»¶æ ‡ç­¾å¤±è´¥ %s: %v", filepath.Base(mediaPath), err)
		return false
	}

	if len(strings.TrimSpace(string(mediaTagOutput))) == 0 {
		logger.Printf("âŒ æ ‡ç­¾ %s åœ¨åª’ä½“æ–‡ä»¶ä¸­æœªæ‰¾åˆ° %s", tagToVerify, filepath.Base(mediaPath))
		return false
	}

	logger.Printf("âœ… éªŒè¯æˆåŠŸ: æ ‡ç­¾ '%s' å·²æ­£ç¡®åˆå¹¶", tagToVerify)
	return true
}

// ====== å»é‡åŠŸèƒ½ ======

func runDedup(args []string) {
	fs := flag.NewFlagSet("dedup", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	trashDir := fs.String("trash", "", "ğŸ—‘ï¸  åƒåœ¾ç®±ç›®å½•ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½•å’Œåƒåœ¾ç®±ç›®å½•")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹åª’ä½“æ–‡ä»¶å»é‡...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ—‘ï¸  åƒåœ¾ç®±: %s", *trashDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// åˆ›å»ºåƒåœ¾ç®±ç›®å½•
	if !*dryRun {
		if err := os.MkdirAll(*trashDir, 0755); err != nil {
			logger.Fatalf("âŒ åˆ›å»ºåƒåœ¾ç®±ç›®å½•å¤±è´¥: %v", err)
		}
	}

	// æ‰«æåª’ä½“æ–‡ä»¶
	mediaFiles, err := scanMediaFiles(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«æåª’ä½“æ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªåª’ä½“æ–‡ä»¶", len(mediaFiles))

	// è®¡ç®—å“ˆå¸Œå¹¶æ£€æµ‹é‡å¤
	hashMap := make(map[string]string) // hash -> first file path
	duplicates := 0
	moved := 0

	for _, file := range mediaFiles {
		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("âš ï¸  è®¡ç®—å“ˆå¸Œå¤±è´¥: %s: %v", file, err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			// å‘ç°é‡å¤
			logger.Printf("ğŸ” å‘ç°é‡å¤: %s <-> %s", filepath.Base(file), filepath.Base(existingFile))
			duplicates++

			if !*dryRun {
				// ç§»åŠ¨åˆ°åƒåœ¾ç®±
				trashPath := filepath.Join(*trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("âŒ ç§»åŠ¨å¤±è´¥: %s: %v", file, err)
				} else {
					logger.Printf("âœ… å·²ç§»åŠ¨åˆ°åƒåœ¾ç®±: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("ğŸ“Š å»é‡å®Œæˆ: å‘ç°é‡å¤ %d, å·²ç§»åŠ¨ %d", duplicates, moved)
}

// scanMediaFiles æ‰«æåª’ä½“æ–‡ä»¶
func scanMediaFiles(dir string) ([]string, error) {
	var mediaFiles []string
	mediaExts := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true,
		".mp4": true, ".mov": true, ".avi": true, ".mkv": true,
		".jxl": true, ".avif": true, ".heic": true, ".heif": true,
		".webp": true, ".bmp": true, ".tiff": true, ".tif": true,
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			ext := strings.ToLower(filepath.Ext(path))
			if mediaExts[ext] {
				mediaFiles = append(mediaFiles, path)
			}
		}
		return nil
	})
	return mediaFiles, err
}

// calculateHash è®¡ç®—æ–‡ä»¶SHA256å“ˆå¸Œ
// æ”¯æŒåŒ…å«ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„
func calculateHash(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", hasher.Sum(nil)), nil
}

// ====== æ‰©å±•åè§„èŒƒåŒ–åŠŸèƒ½ ======

func runNormalize(args []string) {
	fs := flag.NewFlagSet("normalize", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½• (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹æ‰©å±•åè§„èŒƒåŒ–...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// æ‰«æéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶
	files, err := scanFilesForNormalization(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«ææ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶", len(files))

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if *dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†é‡å‘½å: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		// æ‰§è¡Œé‡å‘½å
		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("âŒ é‡å‘½åå¤±è´¥: %s: %v", filepath.Base(oldPath), err)
			failed++
			continue
		}

		logger.Printf("âœ… é‡å‘½åæˆåŠŸ: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("ğŸ“Š è§„èŒƒåŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", normalized, failed)
}

// scanFilesForNormalization æ‰«æéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶
// è¿”å› map[æ—§è·¯å¾„]æ–°è·¯å¾„
func scanFilesForNormalization(dir string) (map[string]string, error) {
	needsNormalization := make(map[string]string)

	// æ‰©å±•åæ˜ å°„è§„åˆ™
	normalizationMap := map[string]string{
		".jpeg": ".jpg",
		".JPEG": ".jpg",
		".tiff": ".tif",
		".TIFF": ".tif",
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		ext := filepath.Ext(path)
		if newExt, shouldNormalize := normalizationMap[ext]; shouldNormalize {
			newPath := strings.TrimSuffix(path, ext) + newExt
			needsNormalization[path] = newPath
		}

		return nil
	})

	return needsNormalization, err
}

// ====== è‡ªåŠ¨æ‰§è¡ŒåŠŸèƒ½ ======

func runAuto(args []string) {
	fs := flag.NewFlagSet("auto", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	trashDir := fs.String("trash", "", "ğŸ—‘ï¸  åƒåœ¾ç®±ç›®å½•ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½•å’Œåƒåœ¾ç®±ç›®å½•")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸš€ å¼€å§‹è‡ªåŠ¨å¤„ç†åª’ä½“æ–‡ä»¶...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ—‘ï¸  åƒåœ¾ç®±: %s", *trashDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)
	logger.Println()

	// æ­¥éª¤1: æ‰©å±•åè§„èŒƒåŒ–
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 1/3: æ‰©å±•åè§„èŒƒåŒ–")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runNormalizeInternal(*inputDir, *dryRun)
	logger.Println()

	// æ­¥éª¤2: XMPå…ƒæ•°æ®åˆå¹¶
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 2/3: XMPå…ƒæ•°æ®åˆå¹¶")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runMergeXMPInternal(*inputDir, *dryRun)
	logger.Println()

	// æ­¥éª¤3: é‡å¤æ–‡ä»¶æ£€æµ‹
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 3/3: é‡å¤æ–‡ä»¶æ£€æµ‹å’Œæ¸…ç†")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runDedupInternal(*inputDir, *trashDir, *dryRun)
	logger.Println()

	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ‰ è‡ªåŠ¨å¤„ç†å®Œæˆï¼")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
}

// runNormalizeInternal å†…éƒ¨è°ƒç”¨çš„è§„èŒƒåŒ–å‡½æ•°
func runNormalizeInternal(inputDir string, dryRun bool) {
	logger.Printf("ğŸ” æ‰«æéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶: %s", inputDir)

	files, err := scanFilesForNormalization(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«ææ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶", len(files))

	if len(files) == 0 {
		logger.Printf("âœ… æ— éœ€è§„èŒƒåŒ–,æ‰€æœ‰æ–‡ä»¶æ‰©å±•åå·²æ ‡å‡†åŒ–")
		return
	}

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†é‡å‘½å: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("âŒ é‡å‘½åå¤±è´¥: %s -> %s: %v", filepath.Base(oldPath), filepath.Base(newPath), err)
			failed++
			continue
		}

		logger.Printf("âœ… é‡å‘½åæˆåŠŸ: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Printf("ğŸ“Š è§„èŒƒåŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", normalized, failed)
	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
}

// runMergeXMPInternal å†…éƒ¨è°ƒç”¨çš„XMPåˆå¹¶å‡½æ•°(å¹¶å‘ç‰ˆæœ¬)
func runMergeXMPInternal(inputDir string, dryRun bool) {
	logger.Printf("ğŸ” æ‰«æXMPæ–‡ä»¶: %s", inputDir)

	xmpFiles, err := scanXMPFiles(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«æXMPæ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªXMPæ–‡ä»¶", len(xmpFiles))

	if len(xmpFiles) == 0 {
		logger.Printf("âœ… æ— éœ€åˆå¹¶,æœªå‘ç°XMPæ–‡ä»¶")
		return
	}

	// æ™ºèƒ½è®¡ç®—å¹¶å‘æ•°(å‚è€ƒuniversal_converter)
	workers := runtime.NumCPU()
	if workers > 8 {
		workers = 8 // é™åˆ¶æœ€å¤§å¹¶å‘æ•°
	}
	logger.Printf("âš¡ å¹¶å‘çº¿ç¨‹æ•°: %d", workers)

	// å¹¶å‘ç»Ÿè®¡
	var merged, failed, deleted int32
	var wg sync.WaitGroup
	var mu sync.Mutex // ç”¨äºä¿æŠ¤æ—¥å¿—è¾“å‡º

	// åˆ›å»ºå·¥ä½œé€šé“
	xmpChan := make(chan string, len(xmpFiles))

	// è¿›åº¦è®¡æ•°
	processed := int32(0)
	total := int32(len(xmpFiles))

	// å¯åŠ¨å·¥ä½œåç¨‹
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()

			for xmpFile := range xmpChan {
				mediaFile := findMediaFile(xmpFile)
				if mediaFile == "" {
					mu.Lock()
					logger.Printf("âš ï¸  æœªæ‰¾åˆ°å¯¹åº”åª’ä½“æ–‡ä»¶: %s", filepath.Base(xmpFile))
					mu.Unlock()
					atomic.AddInt32(&failed, 1)
					atomic.AddInt32(&processed, 1)
					continue
				}

				if dryRun {
					mu.Lock()
					logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†åˆå¹¶: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
					mu.Unlock()
					atomic.AddInt32(&merged, 1)
					atomic.AddInt32(&processed, 1)
					continue
				}

				if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
					mu.Lock()
					logger.Printf("âŒ åˆå¹¶å¤±è´¥: %s -> %s: %v", filepath.Base(xmpFile), filepath.Base(mediaFile), err)
					mu.Unlock()
					atomic.AddInt32(&failed, 1)
					atomic.AddInt32(&processed, 1)
					continue
				}

				// åˆ é™¤å·²åˆå¹¶çš„XMPæ–‡ä»¶
				if err := os.Remove(xmpFile); err != nil {
					mu.Lock()
					logger.Printf("âš ï¸  åˆ é™¤XMPæ–‡ä»¶å¤±è´¥: %s: %v", filepath.Base(xmpFile), err)
					mu.Unlock()
				} else {
					atomic.AddInt32(&deleted, 1)
				}

				atomic.AddInt32(&merged, 1)
				current := atomic.AddInt32(&processed, 1)

				// æ¯50ä¸ªæ–‡ä»¶æˆ–æœ€åä¸€ä¸ªæ–‡ä»¶æ˜¾ç¤ºè¿›åº¦
				if current%50 == 0 || current == total {
					mu.Lock()
					logger.Printf("â³ XMPåˆå¹¶è¿›åº¦: %d/%d (%.1f%%)", current, total, float64(current)/float64(total)*100)
					mu.Unlock()
				}
			}
		}(i)
	}

	// å‘é€ä»»åŠ¡åˆ°é€šé“
	for _, xmpFile := range xmpFiles {
		xmpChan <- xmpFile
	}
	close(xmpChan)

	// ç­‰å¾…æ‰€æœ‰å·¥ä½œå®Œæˆ
	wg.Wait()

	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Printf("ğŸ“Š åˆå¹¶å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", merged, failed)
	logger.Printf("ğŸ—‘ï¸  å·²åˆ é™¤XMP: %d ä¸ª", deleted)
	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
}

// runDedupInternal å†…éƒ¨è°ƒç”¨çš„å»é‡å‡½æ•°
func runDedupInternal(inputDir string, trashDir string, dryRun bool) {
	logger.Printf("ğŸ” æ‰«æåª’ä½“æ–‡ä»¶è¿›è¡Œå»é‡: %s", inputDir)
	logger.Printf("ğŸ—‘ï¸  åƒåœ¾ç®±ç›®å½•: %s", trashDir)

	if !dryRun {
		if err := os.MkdirAll(trashDir, 0755); err != nil {
			logger.Printf("âŒ åˆ›å»ºåƒåœ¾ç®±ç›®å½•å¤±è´¥: %v", err)
			return
		}
	}

	mediaFiles, err := scanMediaFiles(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«æåª’ä½“æ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªåª’ä½“æ–‡ä»¶,å¼€å§‹è®¡ç®—å“ˆå¸Œå€¼...", len(mediaFiles))

	hashMap := make(map[string]string)
	duplicates := 0
	moved := 0
	processed := 0

	for i, file := range mediaFiles {
		processed++
		if processed%50 == 0 || i == 0 || i == len(mediaFiles)-1 {
			logger.Printf("â³ å»é‡è¿›åº¦: %d/%d (%.1f%%)", processed, len(mediaFiles), float64(processed)/float64(len(mediaFiles))*100)
		}

		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("âš ï¸  è®¡ç®—å“ˆå¸Œå¤±è´¥: %s: %v", filepath.Base(file), err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			logger.Printf("ğŸ” å‘ç°é‡å¤: %s <-> %s (å“ˆå¸Œ: %s...)", filepath.Base(file), filepath.Base(existingFile), hash[:8])
			duplicates++

			if dryRun {
				logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†ç§»åŠ¨: %s", filepath.Base(file))
				moved++
			} else {
				trashPath := filepath.Join(trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("âŒ ç§»åŠ¨å¤±è´¥: %s: %v", filepath.Base(file), err)
				} else {
					logger.Printf("âœ… å·²ç§»åŠ¨åˆ°åƒåœ¾ç®±: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Printf("ğŸ“Š å»é‡å®Œæˆ: å‘ç°é‡å¤ %d, å·²ç§»åŠ¨ %d", duplicates, moved)
	logger.Printf("âœ… å”¯ä¸€æ–‡ä»¶: %d ä¸ª", len(hashMap))
	logger.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
}
