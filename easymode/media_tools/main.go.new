// media_tools - 媒体文件辅助工具集
//
// 功能说明：
// 1. XMP元数据合并 (merge命令)
// 2. 重复媒体文件检测和清理 (dedup命令)
//
// 作者：AI Assistant
// 版本：2.2.0
package main

import (
	"crypto/sha256"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"pixly/utils"
)

// 程序常量定义
const (
	toolName = "media_tools"  // 工具名称
	version  = "2.2.0"        // 程序版本号
	author   = "AI Assistant" // 作者信息
)

// 全局变量定义
var (
	logger *log.Logger // 全局日志记录器
)

// 命令类型
type Command string

const (
	MergeXMP  Command = "merge"     // 合并XMP元数据
	Dedup     Command = "dedup"     // 去重媒体文件
	Normalize Command = "normalize" // 规范化文件扩展名
	Auto      Command = "auto"      // 自动执行全部操作
)

func init() {
	// 设置日志记录器，带大小轮转
	rl, lf, err := utils.NewRotatingLogger("media_tools.log", 50*1024*1024)
	if err != nil {
		log.Fatalf("无法初始化轮转日志: %v", err)
	}
	logger = rl
	_ = lf
}

func main() {
	logger.Printf("🛠️  媒体工具集 v%s", version)
	logger.Printf("✨ 作者: %s", author)

	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := Command(os.Args[1])
	switch command {
	case MergeXMP:
		runMergeXMP(os.Args[2:])
	case Dedup:
		runDedup(os.Args[2:])
	case Normalize:
		runNormalize(os.Args[2:])
	case Auto:
		runAuto(os.Args[2:])
	default:
		logger.Printf("❌ 未知命令: %s", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println(`
媒体工具集 v2.2.0

用法:
  media_tools <命令> [参数]

命令:
  merge      合并XMP侧边文件到媒体文件
  dedup      检测并清理重复媒体文件
  normalize  规范化文件扩展名 (.jpeg→.jpg, .tiff→.tif)
  auto       自动执行全部操作（推荐）

示例:
  # 自动执行全部操作（推荐）
  media_tools auto -dir /path/to/media -trash /path/to/trash

  # 单独执行各项操作
  media_tools merge -dir /path/to/media
  media_tools normalize -dir /path/to/media
  media_tools dedup -dir /path/to/media -trash /path/to/trash

获取命令帮助:
  media_tools merge -h
  media_tools dedup -h
  media_tools normalize -h
  media_tools auto -h
`)
}

// ====== XMP合并功能 ======

func runMergeXMP(args []string) {
	fs := flag.NewFlagSet("merge", flag.ExitOnError)
	inputDir := fs.String("dir", "", "📂 输入目录路径（必需）")
	dryRun := fs.Bool("dry-run", false, "🔍 试运行模式，不实际执行")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("❌ 错误: 必须指定输入目录 (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("🔧 开始XMP元数据合并...")
	logger.Printf("📂 输入目录: %s", *inputDir)
	logger.Printf("🔍 试运行: %v", *dryRun)

	// 扫描XMP文件
	xmpFiles, err := scanXMPFiles(*inputDir)
	if err != nil {
		logger.Fatalf("❌ 扫描XMP文件失败: %v", err)
	}

	logger.Printf("📊 找到 %d 个XMP文件", len(xmpFiles))

	merged := 0
	failed := 0

	for _, xmpFile := range xmpFiles {
		mediaFile := findMediaFile(xmpFile)
		if mediaFile == "" {
			logger.Printf("⚠️  未找到对应媒体文件: %s", xmpFile)
			failed++
			continue
		}

		if *dryRun {
			logger.Printf("🔍 [试运行] 将合并: %s -> %s", xmpFile, mediaFile)
			merged++
			continue
		}

		// 执行合并
		if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
			logger.Printf("❌ 合并失败: %s -> %s: %v", xmpFile, mediaFile, err)
			failed++
			continue
		}

		logger.Printf("✅ 合并成功: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
		merged++
	}

	logger.Printf("📊 合并完成: 成功 %d, 失败 %d", merged, failed)
}

// scanXMPFiles 扫描XMP文件
func scanXMPFiles(dir string) ([]string, error) {
	var xmpFiles []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(strings.ToLower(path), ".xmp") {
			xmpFiles = append(xmpFiles, path)
		}
		return nil
	})
	return xmpFiles, err
}

// findMediaFile 查找对应的媒体文件
// 支持包含空格和特殊字符的路径
func findMediaFile(xmpFile string) string {
	// 移除.xmp或.sidecar.xmp后缀
	basePath := strings.TrimSuffix(xmpFile, ".xmp")
	basePath = strings.TrimSuffix(basePath, ".sidecar")

	// 尝试查找对应的媒体文件
	mediaExts := []string{".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mov", ".avi", ".jxl", ".avif", ".heic", ".heif", ".webp", ".bmp", ".tiff", ".tif"}
	for _, ext := range mediaExts {
		mediaFile := basePath + ext
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
		// 尝试大写
		mediaFile = basePath + strings.ToUpper(ext)
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
	}

	return ""
}

// mergeXMPToMedia 合并XMP到媒体文件
func mergeXMPToMedia(xmpFile, mediaFile string) error {
	cmd := exec.Command("exiftool", "-overwrite_original", "-TagsFromFile", xmpFile, mediaFile)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("exiftool执行失败: %v\n输出: %s", err, string(output))
	}
	return nil
}

// ====== 去重功能 ======

func runDedup(args []string) {
	fs := flag.NewFlagSet("dedup", flag.ExitOnError)
	inputDir := fs.String("dir", "", "📂 输入目录路径（必需）")
	trashDir := fs.String("trash", "", "🗑️  垃圾箱目录（必需）")
	dryRun := fs.Bool("dry-run", false, "🔍 试运行模式，不实际执行")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("❌ 错误: 必须指定输入目录和垃圾箱目录")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("🔧 开始媒体文件去重...")
	logger.Printf("📂 输入目录: %s", *inputDir)
	logger.Printf("🗑️  垃圾箱: %s", *trashDir)
	logger.Printf("🔍 试运行: %v", *dryRun)

	// 创建垃圾箱目录
	if !*dryRun {
		if err := os.MkdirAll(*trashDir, 0755); err != nil {
			logger.Fatalf("❌ 创建垃圾箱目录失败: %v", err)
		}
	}

	// 扫描媒体文件
	mediaFiles, err := scanMediaFiles(*inputDir)
	if err != nil {
		logger.Fatalf("❌ 扫描媒体文件失败: %v", err)
	}

	logger.Printf("📊 找到 %d 个媒体文件", len(mediaFiles))

	// 计算哈希并检测重复
	hashMap := make(map[string]string) // hash -> first file path
	duplicates := 0
	moved := 0

	for _, file := range mediaFiles {
		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("⚠️  计算哈希失败: %s: %v", file, err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			// 发现重复
			logger.Printf("🔍 发现重复: %s <-> %s", filepath.Base(file), filepath.Base(existingFile))
			duplicates++

			if !*dryRun {
				// 移动到垃圾箱
				trashPath := filepath.Join(*trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("❌ 移动失败: %s: %v", file, err)
				} else {
					logger.Printf("✅ 已移动到垃圾箱: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("📊 去重完成: 发现重复 %d, 已移动 %d", duplicates, moved)
}

// scanMediaFiles 扫描媒体文件
func scanMediaFiles(dir string) ([]string, error) {
	var mediaFiles []string
	mediaExts := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true,
		".mp4": true, ".mov": true, ".avi": true, ".mkv": true,
		".jxl": true, ".avif": true, ".heic": true, ".heif": true,
		".webp": true, ".bmp": true, ".tiff": true, ".tif": true,
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			ext := strings.ToLower(filepath.Ext(path))
			if mediaExts[ext] {
				mediaFiles = append(mediaFiles, path)
			}
		}
		return nil
	})
	return mediaFiles, err
}

// calculateHash 计算文件SHA256哈希
// 支持包含空格和特殊字符的路径
func calculateHash(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", hasher.Sum(nil)), nil
}

// ====== 扩展名规范化功能 ======

func runNormalize(args []string) {
	fs := flag.NewFlagSet("normalize", flag.ExitOnError)
	inputDir := fs.String("dir", "", "📂 输入目录路径（必需）")
	dryRun := fs.Bool("dry-run", false, "🔍 试运行模式，不实际执行")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("❌ 错误: 必须指定输入目录 (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("🔧 开始扩展名规范化...")
	logger.Printf("📂 输入目录: %s", *inputDir)
	logger.Printf("🔍 试运行: %v", *dryRun)

	// 扫描需要规范化的文件
	files, err := scanFilesForNormalization(*inputDir)
	if err != nil {
		logger.Fatalf("❌ 扫描文件失败: %v", err)
	}

	logger.Printf("📊 找到 %d 个需要规范化的文件", len(files))

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if *dryRun {
			logger.Printf("🔍 [试运行] 将重命名: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		// 执行重命名
		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("❌ 重命名失败: %s: %v", filepath.Base(oldPath), err)
			failed++
			continue
		}

		logger.Printf("✅ 重命名成功: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("📊 规范化完成: 成功 %d, 失败 %d", normalized, failed)
}

// scanFilesForNormalization 扫描需要规范化的文件
// 返回 map[旧路径]新路径
func scanFilesForNormalization(dir string) (map[string]string, error) {
	needsNormalization := make(map[string]string)

	// 扩展名映射规则
	normalizationMap := map[string]string{
		".jpeg": ".jpg",
		".JPEG": ".jpg",
		".tiff": ".tif",
		".TIFF": ".tif",
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		ext := filepath.Ext(path)
		if newExt, shouldNormalize := normalizationMap[ext]; shouldNormalize {
			newPath := strings.TrimSuffix(path, ext) + newExt
			needsNormalization[path] = newPath
		}

		return nil
	})

	return needsNormalization, err
}

// ====== 自动执行功能 ======

func runAuto(args []string) {
	fs := flag.NewFlagSet("auto", flag.ExitOnError)
	inputDir := fs.String("dir", "", "📂 输入目录路径（必需）")
	trashDir := fs.String("trash", "", "🗑️  垃圾箱目录（必需）")
	dryRun := fs.Bool("dry-run", false, "🔍 试运行模式，不实际执行")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("❌ 错误: 必须指定输入目录和垃圾箱目录")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("🚀 开始自动处理媒体文件...")
	logger.Printf("📂 输入目录: %s", *inputDir)
	logger.Printf("🗑️  垃圾箱: %s", *trashDir)
	logger.Printf("🔍 试运行: %v", *dryRun)
	logger.Println()

	// 步骤1: 扩展名规范化
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	logger.Println("📋 步骤 1/3: 扩展名规范化")
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	runNormalizeInternal(*inputDir, *dryRun)
	logger.Println()

	// 步骤2: XMP元数据合并
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	logger.Println("📋 步骤 2/3: XMP元数据合并")
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	runMergeXMPInternal(*inputDir, *dryRun)
	logger.Println()

	// 步骤3: 重复文件检测
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	logger.Println("📋 步骤 3/3: 重复文件检测和清理")
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	runDedupInternal(*inputDir, *trashDir, *dryRun)
	logger.Println()

	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	logger.Println("🎉 自动处理完成！")
	logger.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
}

// runNormalizeInternal 内部调用的规范化函数
func runNormalizeInternal(inputDir string, dryRun bool) {
	files, err := scanFilesForNormalization(inputDir)
	if err != nil {
		logger.Printf("❌ 扫描文件失败: %v", err)
		return
	}

	logger.Printf("📊 找到 %d 个需要规范化的文件", len(files))

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if dryRun {
			logger.Printf("🔍 [试运行] 将重命名: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("❌ 重命名失败: %s: %v", filepath.Base(oldPath), err)
			failed++
			continue
		}

		logger.Printf("✅ 重命名成功: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("📊 规范化完成: 成功 %d, 失败 %d", normalized, failed)
}

// runMergeXMPInternal 内部调用的XMP合并函数
func runMergeXMPInternal(inputDir string, dryRun bool) {
	xmpFiles, err := scanXMPFiles(inputDir)
	if err != nil {
		logger.Printf("❌ 扫描XMP文件失败: %v", err)
		return
	}

	logger.Printf("📊 找到 %d 个XMP文件", len(xmpFiles))

	merged := 0
	failed := 0

	for _, xmpFile := range xmpFiles {
		mediaFile := findMediaFile(xmpFile)
		if mediaFile == "" {
			logger.Printf("⚠️  未找到对应媒体文件: %s", filepath.Base(xmpFile))
			failed++
			continue
		}

		if dryRun {
			logger.Printf("🔍 [试运行] 将合并: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
			merged++
			continue
		}

		if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
			logger.Printf("❌ 合并失败: %s -> %s: %v", filepath.Base(xmpFile), filepath.Base(mediaFile), err)
			failed++
			continue
		}

		logger.Printf("✅ 合并成功: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
		merged++
	}

	logger.Printf("📊 合并完成: 成功 %d, 失败 %d", merged, failed)
}

// runDedupInternal 内部调用的去重函数
func runDedupInternal(inputDir string, trashDir string, dryRun bool) {
	if !dryRun {
		if err := os.MkdirAll(trashDir, 0755); err != nil {
			logger.Printf("❌ 创建垃圾箱目录失败: %v", err)
			return
		}
	}

	mediaFiles, err := scanMediaFiles(inputDir)
	if err != nil {
		logger.Printf("❌ 扫描媒体文件失败: %v", err)
		return
	}

	logger.Printf("📊 找到 %d 个媒体文件", len(mediaFiles))

	hashMap := make(map[string]string)
	duplicates := 0
	moved := 0

	for _, file := range mediaFiles {
		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("⚠️  计算哈希失败: %s: %v", filepath.Base(file), err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			logger.Printf("🔍 发现重复: %s <-> %s", filepath.Base(file), filepath.Base(existingFile))
			duplicates++

			if dryRun {
				logger.Printf("🔍 [试运行] 将移动: %s", filepath.Base(file))
				moved++
			} else {
				trashPath := filepath.Join(trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("❌ 移动失败: %s: %v", filepath.Base(file), err)
				} else {
					logger.Printf("✅ 已移动到垃圾箱: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("📊 去重完成: 发现重复 %d, 已移动 %d", duplicates, moved)
}
