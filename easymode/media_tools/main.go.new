// media_tools - åª’ä½“æ–‡ä»¶è¾…åŠ©å·¥å…·é›†
//
// åŠŸèƒ½è¯´æ˜ï¼š
// 1. XMPå…ƒæ•°æ®åˆå¹¶ (mergeå‘½ä»¤)
// 2. é‡å¤åª’ä½“æ–‡ä»¶æ£€æµ‹å’Œæ¸…ç† (dedupå‘½ä»¤)
//
// ä½œè€…ï¼šAI Assistant
// ç‰ˆæœ¬ï¼š2.2.0
package main

import (
	"crypto/sha256"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"pixly/utils"
)

// ç¨‹åºå¸¸é‡å®šä¹‰
const (
	toolName = "media_tools"  // å·¥å…·åç§°
	version  = "2.2.0"        // ç¨‹åºç‰ˆæœ¬å·
	author   = "AI Assistant" // ä½œè€…ä¿¡æ¯
)

// å…¨å±€å˜é‡å®šä¹‰
var (
	logger *log.Logger // å…¨å±€æ—¥å¿—è®°å½•å™¨
)

// å‘½ä»¤ç±»å‹
type Command string

const (
	MergeXMP  Command = "merge"     // åˆå¹¶XMPå…ƒæ•°æ®
	Dedup     Command = "dedup"     // å»é‡åª’ä½“æ–‡ä»¶
	Normalize Command = "normalize" // è§„èŒƒåŒ–æ–‡ä»¶æ‰©å±•å
	Auto      Command = "auto"      // è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œ
)

func init() {
	// è®¾ç½®æ—¥å¿—è®°å½•å™¨ï¼Œå¸¦å¤§å°è½®è½¬
	rl, lf, err := utils.NewRotatingLogger("media_tools.log", 50*1024*1024)
	if err != nil {
		log.Fatalf("æ— æ³•åˆå§‹åŒ–è½®è½¬æ—¥å¿—: %v", err)
	}
	logger = rl
	_ = lf
}

func main() {
	logger.Printf("ğŸ› ï¸  åª’ä½“å·¥å…·é›† v%s", version)
	logger.Printf("âœ¨ ä½œè€…: %s", author)

	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := Command(os.Args[1])
	switch command {
	case MergeXMP:
		runMergeXMP(os.Args[2:])
	case Dedup:
		runDedup(os.Args[2:])
	case Normalize:
		runNormalize(os.Args[2:])
	case Auto:
		runAuto(os.Args[2:])
	default:
		logger.Printf("âŒ æœªçŸ¥å‘½ä»¤: %s", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println(`
åª’ä½“å·¥å…·é›† v2.2.0

ç”¨æ³•:
  media_tools <å‘½ä»¤> [å‚æ•°]

å‘½ä»¤:
  merge      åˆå¹¶XMPä¾§è¾¹æ–‡ä»¶åˆ°åª’ä½“æ–‡ä»¶
  dedup      æ£€æµ‹å¹¶æ¸…ç†é‡å¤åª’ä½“æ–‡ä»¶
  normalize  è§„èŒƒåŒ–æ–‡ä»¶æ‰©å±•å (.jpegâ†’.jpg, .tiffâ†’.tif)
  auto       è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œï¼ˆæ¨èï¼‰

ç¤ºä¾‹:
  # è‡ªåŠ¨æ‰§è¡Œå…¨éƒ¨æ“ä½œï¼ˆæ¨èï¼‰
  media_tools auto -dir /path/to/media -trash /path/to/trash

  # å•ç‹¬æ‰§è¡Œå„é¡¹æ“ä½œ
  media_tools merge -dir /path/to/media
  media_tools normalize -dir /path/to/media
  media_tools dedup -dir /path/to/media -trash /path/to/trash

è·å–å‘½ä»¤å¸®åŠ©:
  media_tools merge -h
  media_tools dedup -h
  media_tools normalize -h
  media_tools auto -h
`)
}

// ====== XMPåˆå¹¶åŠŸèƒ½ ======

func runMergeXMP(args []string) {
	fs := flag.NewFlagSet("merge", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½• (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹XMPå…ƒæ•°æ®åˆå¹¶...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// æ‰«æXMPæ–‡ä»¶
	xmpFiles, err := scanXMPFiles(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«æXMPæ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªXMPæ–‡ä»¶", len(xmpFiles))

	merged := 0
	failed := 0

	for _, xmpFile := range xmpFiles {
		mediaFile := findMediaFile(xmpFile)
		if mediaFile == "" {
			logger.Printf("âš ï¸  æœªæ‰¾åˆ°å¯¹åº”åª’ä½“æ–‡ä»¶: %s", xmpFile)
			failed++
			continue
		}

		if *dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†åˆå¹¶: %s -> %s", xmpFile, mediaFile)
			merged++
			continue
		}

		// æ‰§è¡Œåˆå¹¶
		if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
			logger.Printf("âŒ åˆå¹¶å¤±è´¥: %s -> %s: %v", xmpFile, mediaFile, err)
			failed++
			continue
		}

		logger.Printf("âœ… åˆå¹¶æˆåŠŸ: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
		merged++
	}

	logger.Printf("ğŸ“Š åˆå¹¶å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", merged, failed)
}

// scanXMPFiles æ‰«æXMPæ–‡ä»¶
func scanXMPFiles(dir string) ([]string, error) {
	var xmpFiles []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(strings.ToLower(path), ".xmp") {
			xmpFiles = append(xmpFiles, path)
		}
		return nil
	})
	return xmpFiles, err
}

// findMediaFile æŸ¥æ‰¾å¯¹åº”çš„åª’ä½“æ–‡ä»¶
// æ”¯æŒåŒ…å«ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„
func findMediaFile(xmpFile string) string {
	// ç§»é™¤.xmpæˆ–.sidecar.xmpåç¼€
	basePath := strings.TrimSuffix(xmpFile, ".xmp")
	basePath = strings.TrimSuffix(basePath, ".sidecar")

	// å°è¯•æŸ¥æ‰¾å¯¹åº”çš„åª’ä½“æ–‡ä»¶
	mediaExts := []string{".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mov", ".avi", ".jxl", ".avif", ".heic", ".heif", ".webp", ".bmp", ".tiff", ".tif"}
	for _, ext := range mediaExts {
		mediaFile := basePath + ext
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
		// å°è¯•å¤§å†™
		mediaFile = basePath + strings.ToUpper(ext)
		if _, err := os.Stat(mediaFile); err == nil {
			return mediaFile
		}
	}

	return ""
}

// mergeXMPToMedia åˆå¹¶XMPåˆ°åª’ä½“æ–‡ä»¶
func mergeXMPToMedia(xmpFile, mediaFile string) error {
	cmd := exec.Command("exiftool", "-overwrite_original", "-TagsFromFile", xmpFile, mediaFile)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("exiftoolæ‰§è¡Œå¤±è´¥: %v\nè¾“å‡º: %s", err, string(output))
	}
	return nil
}

// ====== å»é‡åŠŸèƒ½ ======

func runDedup(args []string) {
	fs := flag.NewFlagSet("dedup", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	trashDir := fs.String("trash", "", "ğŸ—‘ï¸  åƒåœ¾ç®±ç›®å½•ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½•å’Œåƒåœ¾ç®±ç›®å½•")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹åª’ä½“æ–‡ä»¶å»é‡...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ—‘ï¸  åƒåœ¾ç®±: %s", *trashDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// åˆ›å»ºåƒåœ¾ç®±ç›®å½•
	if !*dryRun {
		if err := os.MkdirAll(*trashDir, 0755); err != nil {
			logger.Fatalf("âŒ åˆ›å»ºåƒåœ¾ç®±ç›®å½•å¤±è´¥: %v", err)
		}
	}

	// æ‰«æåª’ä½“æ–‡ä»¶
	mediaFiles, err := scanMediaFiles(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«æåª’ä½“æ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªåª’ä½“æ–‡ä»¶", len(mediaFiles))

	// è®¡ç®—å“ˆå¸Œå¹¶æ£€æµ‹é‡å¤
	hashMap := make(map[string]string) // hash -> first file path
	duplicates := 0
	moved := 0

	for _, file := range mediaFiles {
		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("âš ï¸  è®¡ç®—å“ˆå¸Œå¤±è´¥: %s: %v", file, err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			// å‘ç°é‡å¤
			logger.Printf("ğŸ” å‘ç°é‡å¤: %s <-> %s", filepath.Base(file), filepath.Base(existingFile))
			duplicates++

			if !*dryRun {
				// ç§»åŠ¨åˆ°åƒåœ¾ç®±
				trashPath := filepath.Join(*trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("âŒ ç§»åŠ¨å¤±è´¥: %s: %v", file, err)
				} else {
					logger.Printf("âœ… å·²ç§»åŠ¨åˆ°åƒåœ¾ç®±: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("ğŸ“Š å»é‡å®Œæˆ: å‘ç°é‡å¤ %d, å·²ç§»åŠ¨ %d", duplicates, moved)
}

// scanMediaFiles æ‰«æåª’ä½“æ–‡ä»¶
func scanMediaFiles(dir string) ([]string, error) {
	var mediaFiles []string
	mediaExts := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true,
		".mp4": true, ".mov": true, ".avi": true, ".mkv": true,
		".jxl": true, ".avif": true, ".heic": true, ".heif": true,
		".webp": true, ".bmp": true, ".tiff": true, ".tif": true,
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			ext := strings.ToLower(filepath.Ext(path))
			if mediaExts[ext] {
				mediaFiles = append(mediaFiles, path)
			}
		}
		return nil
	})
	return mediaFiles, err
}

// calculateHash è®¡ç®—æ–‡ä»¶SHA256å“ˆå¸Œ
// æ”¯æŒåŒ…å«ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„
func calculateHash(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", hasher.Sum(nil)), nil
}

// ====== æ‰©å±•åè§„èŒƒåŒ–åŠŸèƒ½ ======

func runNormalize(args []string) {
	fs := flag.NewFlagSet("normalize", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½• (-dir)")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸ”§ å¼€å§‹æ‰©å±•åè§„èŒƒåŒ–...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)

	// æ‰«æéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶
	files, err := scanFilesForNormalization(*inputDir)
	if err != nil {
		logger.Fatalf("âŒ æ‰«ææ–‡ä»¶å¤±è´¥: %v", err)
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶", len(files))

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if *dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†é‡å‘½å: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		// æ‰§è¡Œé‡å‘½å
		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("âŒ é‡å‘½åå¤±è´¥: %s: %v", filepath.Base(oldPath), err)
			failed++
			continue
		}

		logger.Printf("âœ… é‡å‘½åæˆåŠŸ: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("ğŸ“Š è§„èŒƒåŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", normalized, failed)
}

// scanFilesForNormalization æ‰«æéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶
// è¿”å› map[æ—§è·¯å¾„]æ–°è·¯å¾„
func scanFilesForNormalization(dir string) (map[string]string, error) {
	needsNormalization := make(map[string]string)

	// æ‰©å±•åæ˜ å°„è§„åˆ™
	normalizationMap := map[string]string{
		".jpeg": ".jpg",
		".JPEG": ".jpg",
		".tiff": ".tif",
		".TIFF": ".tif",
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		ext := filepath.Ext(path)
		if newExt, shouldNormalize := normalizationMap[ext]; shouldNormalize {
			newPath := strings.TrimSuffix(path, ext) + newExt
			needsNormalization[path] = newPath
		}

		return nil
	})

	return needsNormalization, err
}

// ====== è‡ªåŠ¨æ‰§è¡ŒåŠŸèƒ½ ======

func runAuto(args []string) {
	fs := flag.NewFlagSet("auto", flag.ExitOnError)
	inputDir := fs.String("dir", "", "ğŸ“‚ è¾“å…¥ç›®å½•è·¯å¾„ï¼ˆå¿…éœ€ï¼‰")
	trashDir := fs.String("trash", "", "ğŸ—‘ï¸  åƒåœ¾ç®±ç›®å½•ï¼ˆå¿…éœ€ï¼‰")
	dryRun := fs.Bool("dry-run", false, "ğŸ” è¯•è¿è¡Œæ¨¡å¼ï¼Œä¸å®é™…æ‰§è¡Œ")

	fs.Parse(args)

	if *inputDir == "" || *trashDir == "" {
		logger.Println("âŒ é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å…¥ç›®å½•å’Œåƒåœ¾ç®±ç›®å½•")
		fs.PrintDefaults()
		os.Exit(1)
	}

	logger.Printf("ğŸš€ å¼€å§‹è‡ªåŠ¨å¤„ç†åª’ä½“æ–‡ä»¶...")
	logger.Printf("ğŸ“‚ è¾“å…¥ç›®å½•: %s", *inputDir)
	logger.Printf("ğŸ—‘ï¸  åƒåœ¾ç®±: %s", *trashDir)
	logger.Printf("ğŸ” è¯•è¿è¡Œ: %v", *dryRun)
	logger.Println()

	// æ­¥éª¤1: æ‰©å±•åè§„èŒƒåŒ–
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 1/3: æ‰©å±•åè§„èŒƒåŒ–")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runNormalizeInternal(*inputDir, *dryRun)
	logger.Println()

	// æ­¥éª¤2: XMPå…ƒæ•°æ®åˆå¹¶
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 2/3: XMPå…ƒæ•°æ®åˆå¹¶")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runMergeXMPInternal(*inputDir, *dryRun)
	logger.Println()

	// æ­¥éª¤3: é‡å¤æ–‡ä»¶æ£€æµ‹
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ“‹ æ­¥éª¤ 3/3: é‡å¤æ–‡ä»¶æ£€æµ‹å’Œæ¸…ç†")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	runDedupInternal(*inputDir, *trashDir, *dryRun)
	logger.Println()

	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	logger.Println("ğŸ‰ è‡ªåŠ¨å¤„ç†å®Œæˆï¼")
	logger.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
}

// runNormalizeInternal å†…éƒ¨è°ƒç”¨çš„è§„èŒƒåŒ–å‡½æ•°
func runNormalizeInternal(inputDir string, dryRun bool) {
	files, err := scanFilesForNormalization(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«ææ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªéœ€è¦è§„èŒƒåŒ–çš„æ–‡ä»¶", len(files))

	normalized := 0
	failed := 0

	for oldPath, newPath := range files {
		if dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†é‡å‘½å: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
			normalized++
			continue
		}

		if err := os.Rename(oldPath, newPath); err != nil {
			logger.Printf("âŒ é‡å‘½åå¤±è´¥: %s: %v", filepath.Base(oldPath), err)
			failed++
			continue
		}

		logger.Printf("âœ… é‡å‘½åæˆåŠŸ: %s -> %s", filepath.Base(oldPath), filepath.Base(newPath))
		normalized++
	}

	logger.Printf("ğŸ“Š è§„èŒƒåŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", normalized, failed)
}

// runMergeXMPInternal å†…éƒ¨è°ƒç”¨çš„XMPåˆå¹¶å‡½æ•°
func runMergeXMPInternal(inputDir string, dryRun bool) {
	xmpFiles, err := scanXMPFiles(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«æXMPæ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªXMPæ–‡ä»¶", len(xmpFiles))

	merged := 0
	failed := 0

	for _, xmpFile := range xmpFiles {
		mediaFile := findMediaFile(xmpFile)
		if mediaFile == "" {
			logger.Printf("âš ï¸  æœªæ‰¾åˆ°å¯¹åº”åª’ä½“æ–‡ä»¶: %s", filepath.Base(xmpFile))
			failed++
			continue
		}

		if dryRun {
			logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†åˆå¹¶: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
			merged++
			continue
		}

		if err := mergeXMPToMedia(xmpFile, mediaFile); err != nil {
			logger.Printf("âŒ åˆå¹¶å¤±è´¥: %s -> %s: %v", filepath.Base(xmpFile), filepath.Base(mediaFile), err)
			failed++
			continue
		}

		logger.Printf("âœ… åˆå¹¶æˆåŠŸ: %s -> %s", filepath.Base(xmpFile), filepath.Base(mediaFile))
		merged++
	}

	logger.Printf("ğŸ“Š åˆå¹¶å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", merged, failed)
}

// runDedupInternal å†…éƒ¨è°ƒç”¨çš„å»é‡å‡½æ•°
func runDedupInternal(inputDir string, trashDir string, dryRun bool) {
	if !dryRun {
		if err := os.MkdirAll(trashDir, 0755); err != nil {
			logger.Printf("âŒ åˆ›å»ºåƒåœ¾ç®±ç›®å½•å¤±è´¥: %v", err)
			return
		}
	}

	mediaFiles, err := scanMediaFiles(inputDir)
	if err != nil {
		logger.Printf("âŒ æ‰«æåª’ä½“æ–‡ä»¶å¤±è´¥: %v", err)
		return
	}

	logger.Printf("ğŸ“Š æ‰¾åˆ° %d ä¸ªåª’ä½“æ–‡ä»¶", len(mediaFiles))

	hashMap := make(map[string]string)
	duplicates := 0
	moved := 0

	for _, file := range mediaFiles {
		hash, err := calculateHash(file)
		if err != nil {
			logger.Printf("âš ï¸  è®¡ç®—å“ˆå¸Œå¤±è´¥: %s: %v", filepath.Base(file), err)
			continue
		}

		if existingFile, exists := hashMap[hash]; exists {
			logger.Printf("ğŸ” å‘ç°é‡å¤: %s <-> %s", filepath.Base(file), filepath.Base(existingFile))
			duplicates++

			if dryRun {
				logger.Printf("ğŸ” [è¯•è¿è¡Œ] å°†ç§»åŠ¨: %s", filepath.Base(file))
				moved++
			} else {
				trashPath := filepath.Join(trashDir, filepath.Base(file))
				if err := os.Rename(file, trashPath); err != nil {
					logger.Printf("âŒ ç§»åŠ¨å¤±è´¥: %s: %v", filepath.Base(file), err)
				} else {
					logger.Printf("âœ… å·²ç§»åŠ¨åˆ°åƒåœ¾ç®±: %s", filepath.Base(file))
					moved++
				}
			}
		} else {
			hashMap[hash] = file
		}
	}

	logger.Printf("ğŸ“Š å»é‡å®Œæˆ: å‘ç°é‡å¤ %d, å·²ç§»åŠ¨ %d", duplicates, moved)
}
