# JPEG XL 批量转换工具 - 处理流程技术文档

## 概述

本文档详细介绍了 JPEG XL 批量转换工具的内部处理流程，帮助技术用户理解程序的运行机制和各个组件的工作原理。

## 程序架构

### 核心组件

1. **主控制器 (main.go)**
   - 程序入口点和整体流程控制
   - 命令行参数解析和配置管理
   - 线程池初始化和任务调度

2. **文件处理引擎 (processFileWithOpts)**
   - 单个文件的完整处理流程
   - 文件类型识别和验证
   - 转换、验证、元数据处理的协调

3. **图像转换器 (convertToJxlWithOpts)**
   - 调用 cjxl 工具进行格式转换
   - 根据图像类型选择最优转换策略
   - 动画检测和针对性处理

4. **验证系统 (verifyConversionWithMode)**
   - 无损转换验证
   - 像素级精度检查
   - 动画帧数一致性验证

5. **元数据管理器 (copyMetadata)**
   - 多层级 EXIF 数据迁移
   - 文件系统时间戳保护
   - 关键元数据完整性保证

## 详细处理流程

### 1. 程序初始化阶段

```
🚀 程序启动
├── 版本信息显示
├── 依赖工具检查 (cjxl, djxl, exiftool)
├── 命令行参数解析
├── 工作目录准备 (可选复制)
└── 性能配置优化
```

**关键步骤：**
- 检查系统依赖工具的可用性
- 根据 CPU 核心数动态调整工作线程数
- 设置资源并发限制（进程数、文件句柄数）

### 2. 文件扫描阶段

```
🔍 文件扫描
├── 递归遍历目录结构
├── 过滤非图像文件
├── 跳过已存在的 .jxl 文件
├── 跳过符号链接
└── 采样选择（如果启用）
```

**扫描策略：**
- 使用 `godirwalk` 进行高效的目录遍历
- 实时过滤不支持的文件类型
- 支持采样模式，选择中等大小文件进行测试

### 3. 并行处理阶段

```
⚡ 并行处理
├── 线程池任务分配
├── 信号处理（优雅中断）
├── 进度监控和报告
└── 错误处理和重试机制
```

**并发控制：**
- 使用 `ants` 库管理线程池
- 进程级和文件句柄级的并发限制
- 支持 SIGINT/SIGTERM 信号的优雅处理

### 4. 单个文件处理流程

#### 4.1 文件预处理

```
📂 文件预处理
├── 打开文件和权限检查
├── 读取文件头部信息 (261 bytes)
├── 文件类型识别 (filetype 库)
├── 支持格式验证
└── 动画检测 (针对支持的格式)
```

**类型识别：**
- 支持格式：JPG, JPEG, PNG, GIF, APNG, WebP, AVIF, BMP, TIFF, TIF, ICO, CUR, HEIC, HEIF, JFIF, JPE 等
- 动画检测：GIF, APNG, WebP, AVIF, HEIF
- 实时动画帧数检测和首帧验证

#### 4.2 转换执行

```
🔄 转换执行
├── 动画状态检测
├── 转换策略选择
├── cjxl 命令构建
├── 超时控制和重试
└── 转换结果验证
```

**转换策略：**
- JPEG/JFIF/JPE: 无损重编码 (`--lossless_jpeg=1`)
- PNG: 无损转换 + modular (`-d 0 -e 9 --modular 1`)
- GIF: 静态或动画无损转换 (`-d 0 -e 9`)
- WebP: 静态或动画无损转换 (`-d 0 -e 9`)
- AVIF/HEIF: 无损转换 (`-d 0 -e 9`)
- BMP: 无损转换 (`-d 0 -e 9`)
- TIFF/TIF: 无损转换 (`-d 0 -e 9`)
- ICO/CUR: 无损转换 (`-d 0 -e 9`)

#### 4.3 质量验证

```
🔍 质量验证
├── 临时目录创建
├── JXL 解码为原始格式
├── 像素级逐点比较
├── 动画帧数一致性检查
└── 边界和色彩空间验证
```

**验证机制：**
- 非动画：逐像素全量对比
- 动画：首帧像素验证 + 帧数一致性
- 使用 djxl 工具进行解码验证

#### 4.4 元数据处理

```
📋 元数据处理
├── 策略1: 完整元数据迁移
├── 策略2: 关键元数据迁移
├── 策略3: 基础时间戳迁移
├── 策略4: 文件系统时间戳保护
└── macOS Finder 日期同步
```

**多层级回退：**
1. 完整 EXIF/IPTC/XMP 元数据 (`-TagsFromFile original -all:all`)
2. 关键字段（时间戳、方向、GPS等）
3. 基础时间戳
4. 文件系统时间戳作为最后保障

#### 4.5 文件替换

```
📁 文件替换
├── 原始文件删除
├── 临时文件重命名
├── 时间戳校准
├── macOS Finder 兼容性处理
└── 最终验证
```

### 5. 统计和报告阶段

```
📊 统计报告
├── 详细处理日志收集
├── 按格式分类统计
├── 性能分析（处理时间、压缩率）
├── 错误汇总和原因分析
└── 用户友好的摘要输出
```

## 关键技术特性

### 动画检测算法

1. **GIF 动画检测**
   ```go
   g, err := gif.DecodeAll(file)
   return len(g.Image) > 1, nil
   ```

2. **APNG 动画检测**
   - 查找 PNG 文件中的 `acTL` chunk
   - 检测动画控制块的存在

3. **WebP 动画检测**
   - 查找 RIFF 容器中的 `ANIM` chunk
   - 验证动画标识符

4. **AVIF/HEIF 动画检测**
   - 检查文件头中的动画标识
   - 验证容器格式的动画支持

### 性能优化策略

1. **智能线程配置**
   - 根据 CPU 核心数动态调整
   - 避免过度并发导致的系统卡顿
   - 资源限制保护机制

2. **内存管理**
   - 预分配线程池
   - 及时释放临时文件
   - 流式处理大文件

3. **并发控制**
   - 进程级并发限制
   - 文件句柄限制
   - 信号量机制

### 错误处理和恢复

1. **重试机制**
   - 可配置的重试次数
   - 指数退避策略
   - 失败原因记录

2. **优雅降级**
   - 元数据迁移的多层级回退
   - 验证失败时的清理机制
   - 部分失败不影响整体处理

3. **信号处理**
   - SIGINT/SIGTERM 信号捕获
   - 正在处理的任务完成
   - 新任务停止分配

## 命令行参数

程序支持以下命令行参数：

- `-dir STRING`: 输入目录路径
- `-workers INT`: 工作线程数 (0=自动检测)
- `-verify STRING`: 验证模式: strict|fast
- `-copy`: 复制目录到 *_work 后处理
- `-sample INT`: 测试模式: 仅处理N个中等大小文件
- `-skip-exist`: 跳过已存在的 .jxl 文件 (默认:true)
- `-dry-run`: 试运行模式: 仅记录操作不转换
- `-cjxl-threads INT`: 每个转换任务的线程数 (默认:1)
- `-timeout INT`: 单任务超时秒数 (0=无限制)
- `-retries INT`: 失败重试次数 (默认:0)

## 日志系统

### 日志级别和类型

1. **INFO 级别**
   - 程序启动和配置信息
   - 处理进度和状态更新
   - 成功完成的文件信息

2. **WARN 级别**
   - 非关键性错误（如元数据迁移失败）
   - 性能警告（如处理时间过长）
   - 兼容性提醒

3. **ERROR 级别**
   - 文件处理失败
   - 系统资源不足
   - 依赖工具缺失

### 详细日志记录

每个文件的处理过程都会记录：
- 文件基本信息（大小、类型、路径）
- 处理时间统计
- 转换策略选择
- 验证结果
- 元数据迁移状态
- 最终压缩效果

## 扩展性设计

### 新格式支持

添加新图像格式支持需要：
1. 在 `isSupportedImageType` 中添加格式识别
2. 在 `convertToJxlWithOpts` 中添加转换策略
3. 实现对应的动画检测函数（如果需要）
4. 更新验证逻辑以支持新格式

### 性能调优

性能调优的关键参数：
- `workers`: 工作线程数
- `cjxlThreads`: 单任务线程数
- `procLimit`: 进程并发限制
- `fdLimit`: 文件句柄限制
- `timeout`: 单任务超时时间

### 自定义验证策略

可以通过修改 `verifyConversionWithMode` 函数实现：
- 自定义验证精度
- 特定格式的特殊验证逻辑
- 性能与质量的平衡调整

## 总结

JPEG XL 批量转换工具采用模块化设计，通过多层级处理流程确保转换质量和数据完整性。程序具备良好的扩展性和可维护性，能够适应不同的使用场景和性能需求。

关键优势：
- 🎯 无损转换保证
- ⚡ 高性能并行处理
- 🔍 详细的处理透明度
- 🛡️ 健壮的错误处理
- 📊 全面的统计分析
- 🎨 用户友好的界面