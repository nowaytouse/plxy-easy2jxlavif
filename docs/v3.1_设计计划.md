# Pixly v3.1 设计计划：实时学习与预测微调

**版本**: v3.1  
**日期**: 2025-10-25  
**目标**: 为自定义格式支持打基础，实现动态预测优化

---

## 🎯 背景与动机

### v3.0 的局限

虽然v3.0的黄金规则非常有效：

```
PNG  → JXL distance=0      (100%无损)
JPEG → JXL lossless_jpeg=1 (100%可逆)
GIF  → AVIF                (现代编码)
```

但这些规则是**硬编码**的，无法支持：

1. **自定义目标格式**
   - 用户想要 PNG → AVIF（而不是JXL）
   - 用户想要 JPEG → WebP（而不是JXL）

2. **动态参数优化**
   - 根据实际转换结果调整`ExpectedSaving`
   - 根据文件特征选择最优参数

3. **多策略对比**
   - 同一格式可能有多种转换策略
   - 需要知识库支持选择最优策略

### v3.1 的核心价值

> "让Pixly不仅会应用规则，更会根据经验自我优化。"

---

## 📋 核心功能

### 1️⃣ 实时记录集成

**目标**：每次转换自动记录到知识库

#### 实现要点

```go
// 在executeConversionWithPrediction中集成
func (bo *BalanceOptimizer) executeConversionWithPrediction(...) *OptimizationResult {
    // 1. 提取特征
    features, _ := bo.predictor.GetFeatures(filePath)
    
    // 2. 执行转换
    result := bo.convertFile(...)
    
    // 3. 自动记录（Week 7-8已实现）
    if bo.enableKnowledge {
        bo.recordConversion(filePath, features, prediction, predictorName, result)
    }
    
    return result
}
```

#### 优势

- ✅ **零手动操作**：用户无需关心记录
- ✅ **完整数据**：每次转换都被记录
- ✅ **实时反馈**：立即更新统计

---

### 2️⃣ 预测微调器（PredictionTuner）

**目标**：基于历史数据动态调整预测参数

#### 核心机制

```go
type PredictionTuner struct {
    db       *knowledge.Database
    logger   *zap.Logger
    cache    map[string]*TunedParams // 缓存微调结果
}

// TunedParams 微调后的参数
type TunedParams struct {
    OptimalSaving    float64  // 基于历史的最优节省率
    OptimalEffort    int      // 基于文件大小的最优effort
    OptimalCRF       int      // 基于质量的最优CRF
    Confidence       float64  // 微调置信度
    SampleCount      int      // 样本数量
    LastUpdated      time.Time
}
```

#### 微调逻辑

**场景1：PNG预测优化**

```
当前状态（v3.0）:
  ExpectedSaving = 0.95 (固定)

知识库数据（100个样本）:
  实际平均节省 = 0.67 (67%)
  标准差 = 0.05

微调后（v3.1）:
  ExpectedSaving = 0.67 (基于实际数据)
  置信区间 = [0.62, 0.72]
  
结果：
  预测误差从 30% 降至 5%
```

**场景2：自定义格式预测**

```
用户需求：
  PNG → AVIF (而不是默认的JXL)

知识库查询：
  PNG → AVIF的历史记录: 15条
  平均节省: 58%
  平均CRF: 32
  质量通过率: 93%

预测器输出：
  TargetFormat: "avif"
  ExpectedSaving: 0.58
  CRF: 32
  Confidence: 0.75 (样本数偏少，中等置信度)
```

---

### 3️⃣ 自定义格式预测框架

**目标**：支持用户指定目标格式并智能预测参数

#### API设计

```go
// 自定义格式预测
type CustomFormatRequest struct {
    SourceFormat string   // "png", "jpg" etc.
    TargetFormat string   // "jxl", "avif", "webp" etc.
    QualityGoal  string   // "lossless", "high", "balanced", "small"
}

// 预测器扩展
func (p *Predictor) PredictWithCustomTarget(
    filePath string,
    customReq *CustomFormatRequest,
) (*Prediction, error) {
    // 1. 提取特征
    features, _ := p.featureExtractor.Extract(filePath)
    
    // 2. 查询知识库
    tuner := NewPredictionTuner(p.knowledgeDB, p.logger)
    tunedParams := tuner.GetTunedParams(
        features.Format,
        customReq.TargetFormat,
        customReq.QualityGoal,
    )
    
    // 3. 生成预测
    if tunedParams != nil && tunedParams.SampleCount > 10 {
        // 有足够历史数据，使用微调参数
        return p.buildPredictionFromTuned(features, tunedParams)
    } else {
        // 样本不足，使用保守默认值 + 触发探索
        return p.buildConservativePrediction(features, customReq)
    }
}
```

#### 示例使用

```go
// 场景：用户想要 PNG → AVIF
customReq := &CustomFormatRequest{
    SourceFormat: "png",
    TargetFormat: "avif",
    QualityGoal:  "lossless",
}

prediction, err := predictor.PredictWithCustomTarget(filePath, customReq)

// 如果知识库有数据：
//   → 使用历史最优参数
// 如果知识库无数据：
//   → 使用保守默认值
//   → 标记ShouldExplore=true
//   → 触发探索引擎
```

---

### 4️⃣ 渐进式学习

**目标**：随着转换次数增加，预测越来越准确

#### 学习曲线

```
初始状态（0-10次转换）:
  使用硬编码默认值
  Confidence: 0.50
  ExpectedSaving: 保守估计

中期状态（10-100次转换）:
  开始使用历史数据
  Confidence: 0.70 - 0.85
  ExpectedSaving: 历史平均值

成熟状态（100+次转换）:
  高度优化的预测
  Confidence: 0.90+
  ExpectedSaving: 精确预测（误差<5%）
```

#### 自适应阈值

```go
func (pt *PredictionTuner) GetConfidenceThreshold(sampleCount int) float64 {
    switch {
    case sampleCount < 10:
        return 0.60  // 样本少，低阈值，触发探索
    case sampleCount < 50:
        return 0.75  // 中等样本，中等阈值
    case sampleCount < 200:
        return 0.85  // 较多样本，高阈值
    default:
        return 0.90  // 大量样本，高置信度
    }
}
```

---

## 🔧 技术实现

### 数据流

```
┌─────────────┐
│ 文件输入    │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────┐
│ 特征提取                         │
│ - 格式、尺寸、质量等             │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ 知识库查询                       │
│ - 查询历史转换记录               │
│ - 计算最优参数                   │
└──────┬──────────────────────────┘
       │
       ├─────────┬──────────────────┐
       │         │                  │
       ▼         ▼                  ▼
  样本充足   样本不足          自定义格式
       │         │                  │
       ▼         ▼                  ▼
  微调预测   保守预测           混合策略
       │         │                  │
       └─────────┴──────────────────┘
                 │
                 ▼
       ┌─────────────────┐
       │ 执行转换        │
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ 自动记录        │
       │ - 保存到知识库  │
       │ - 更新统计      │
       └─────────────────┘
```

### 缓存机制

```go
// 避免频繁查询数据库
type PredictionCache struct {
    cache map[string]*CachedPrediction
    ttl   time.Duration
    mutex sync.RWMutex
}

type CachedPrediction struct {
    Params      *TunedParams
    CachedAt    time.Time
    HitCount    int
}

// 使用示例
func (pt *PredictionTuner) GetTunedParamsWithCache(
    sourceFormat, targetFormat, quality string,
) *TunedParams {
    key := fmt.Sprintf("%s->%s:%s", sourceFormat, targetFormat, quality)
    
    // 检查缓存
    if cached := pt.cache.Get(key); cached != nil {
        if time.Since(cached.CachedAt) < pt.cacheTTL {
            return cached.Params
        }
    }
    
    // 查询数据库
    params := pt.queryDatabase(sourceFormat, targetFormat, quality)
    
    // 更新缓存
    pt.cache.Set(key, params)
    
    return params
}
```

---

## 📊 预期效果

### 预测准确性提升

| 格式 | v3.0误差 | v3.1预期误差 | 改进 |
|------|----------|--------------|------|
| PNG | 20.8% | **5%** | 75%↓ |
| JPEG | 3.6% | **2%** | 44%↓ |
| GIF | 31.1% | **8%** | 74%↓ |

### 自定义格式支持

```
支持的组合（基于知识库）:
  PNG  → JXL, AVIF, WebP
  JPEG → JXL, AVIF, WebP
  GIF  → AVIF, WebP, JXL
  WebP → JXL, AVIF
  
每种组合都有：
  - 历史最优参数
  - 预期空间节省
  - 质量保证
```

### 学习速度

```
10次转换后:
  - 开始使用历史数据
  - 预测误差下降50%

50次转换后:
  - 预测非常准确
  - 误差<10%

100次转换后:
  - 接近最优状态
  - 误差<5%
```

---

## 🔍 关键挑战与解决方案

### 挑战1：样本不足

**问题**：新格式组合没有历史数据

**解决方案**：
1. 使用保守默认值
2. 触发探索引擎收集数据
3. 标记为"学习中"状态

### 挑战2：数据噪声

**问题**：异常转换影响统计

**解决方案**：
1. 异常检测（已在v3.0实现）
2. 使用中位数而非平均值
3. 置信区间过滤

### 挑战3：缓存失效

**问题**：历史数据更新后缓存过期

**解决方案**：
1. TTL机制（默认1小时）
2. 按记录数触发更新（每100条）
3. 手动刷新API

---

## 🚀 实施路线

### Phase 1: 实时记录（1-2天）
- ✅ 已在v3.0实现基础
- 🔄 集成到所有转换流程
- 🔄 添加自动统计更新

### Phase 2: 预测微调器（2-3天）
- 🔄 实现`PredictionTuner`
- 🔄 基于历史数据计算最优参数
- 🔄 缓存机制

### Phase 3: 自定义格式框架（2-3天）
- 🔄 `PredictWithCustomTarget` API
- 🔄 格式组合查询
- 🔄 混合策略（历史+默认）

### Phase 4: 测试与验证（1-2天）
- 🔄 实时学习测试
- 🔄 预测微调验证
- 🔄 自定义格式测试

### Phase 5: 文档与报告（1天）
- 🔄 v3.1完成报告
- 🔄 API文档
- 🔄 最佳实践

**总计**: 约7-11天

---

## 💡 v3.1 的核心价值

```
v3.0: 黄金规则 + 知识库记录
  → 简单、可靠、可学习

v3.1: 实时学习 + 预测微调 + 自定义格式
  → 动态优化、用户自主、数据驱动

未来: v4.0 分布式知识库
  → 社区智慧、规则共享
```

---

## ✨ 结论

v3.1不是对v3.0的颠覆，而是**自然进化**：

1. **保留黄金规则**：默认策略仍然简单可靠
2. **增强学习能力**：自动优化，越用越准
3. **支持定制化**：用户可选目标格式
4. **数据驱动决策**：基于实际效果而非猜测

> "让Pixly从'专家规则系统'进化为'自我学习专家'。"

