# Pixly v3.0 - 智能参数预测引擎（核心重构）

**项目灵魂**: 预测最佳参数，而非暴力尝试  
**核心使命**: 
1. 🎯 寻求最佳参数 - 避免无脑一刀切转换
2. 🚀 优化为现代格式 - JXL, AVIF, MOV（重封装）
3. 🧠 预测性算法 - 智能预测而非暴力枚举

**版本**: v3.0.0 (Major Refactor)  
**创建日期**: 2025-10-25

---

## 📋 架构简化

### 当前问题分析

**PIXLY最初版本的架构**（来自实际代码分析）：

```go
// 最初版本：3种模式并行
type ConversionMode int
const (
    ModeAutoPlus  // Auto+模式：智能决策 + 平衡优化
    ModeQuality   // Quality模式：纯无损优化
    ModeEmoji     // Emoji模式：激进有损压缩
)
```

**过度复杂的模式系统**：
- ❌ **Auto+ Mode**：包含复杂的质量分析和3步探测流程
- ❌ **Quality Mode**：与Auto+高质量路径重复
- ❌ **Emoji Mode**：表情包专用，与主流程脱节
- ❌ **冗余判断**：同一个文件需要多次分析质量
- ❌ **低效探测**：每个文件最多尝试5次转换（质量90,85,75,60,55）

**新架构（极简 + 智能）**：
```
✅ Auto+ Mode（唯一模式，融合所有优点）
   ├─ 智能参数预测（替代多次尝试）
   ├─ 中质量探索（仅当预测不确定时，2-3次）
   └─ 现代格式优化（JXL静图/AVIF动图/MOV视频）
```

### 最初版本的核心洞察（保留与继承）

从PIXLY最初版本的`strategy.go`中提炼的宝贵经验：

#### 1. 三步平衡优化流程（验证有效）✓

```go
// applyBalancedOptimization - 最初版本的核心算法
func (s *AutoPlusStrategy) applyBalancedOptimization(file *MediaFile) (string, error) {
    // 步骤1: 无损重新包装（Lossless Repackaging）
    //   - JPEG→JXL (lossless_jpeg=1)
    //   - PNG→JXL (distance=0)
    losslessResult, _ := s.attemptLosslessRepackaging(file)
    if losslessResult != "" {
        return losslessResult, nil  // 成功就直接返回
    }
    
    // 步骤2: 数学无损压缩（Mathematical Lossless）
    //   - JPEG→JXL (distance=0, 重新编码)
    //   - PNG→JXL (distance=0)
    mathLossless, _ := s.attemptMathematicalLossless(file)
    if mathLossless != "" {
        return mathLossless, nil
    }
    
    // 步骤3: 有损探测（Lossy Probing）
    //   - 根据文件质量选择探测点
    var qualityTargets []int
    if fileQuality > 70 {
        qualityTargets = []int{90, 85, 75}  // 高质量文件
    } else {
        qualityTargets = []int{60, 55}      // 低质量文件
    }
    
    // 并行或顺序尝试所有质量点
    for _, q := range qualityTargets {
        result := attemptLossyCompression(file, q)
        probeResults = append(probeResults, result)
    }
    
    // 步骤4: 选择最佳结果
    return selectBestProbeResult(probeResults)
}
```

**问题**：
- ⚠️ 每个文件最多需要**5次实际转换**（2次无损 + 3次有损探测）
- ⚠️ 即使文件质量明显（如纯色PNG），仍要走完全部流程
- ⚠️ 没有"学习"能力，每个文件都从零开始

#### 2. 格式决策矩阵（完全保留）✓

最初版本的格式决策非常正确，新版完全继承：

| 原始格式 | 静/动 | 目标格式 | 理由 |
|---------|------|---------|------|
| JPEG | 静 | JXL | 无损重包装优先，失败则distance=0 |
| PNG | 静 | JXL | 无损压缩，RGBA支持完美 |
| PNG | 动 | AVIF | 动画格式，AVIF更优 |
| GIF | 静 | JXL | 静态图用JXL |
| GIF | 动 | AVIF | 动画用AVIF |
| WebP | 静 | JXL | 静态图用JXL |
| WebP | 动 | AVIF | 动画用AVIF |
| HEIC | Live Photo | 跳过 | 保留Live Photo特性 |
| MP4/AVI | - | MOV | 重封装，不重编码 |

**新版改进**：不改变决策矩阵，只改进"如何到达决策"的速度。

#### 3. 质量分析体系（精简但保留核心）

最初版本的质量分析非常详细：

```go
type ImageQualityMetrics struct {
    Complexity           float64  // 图像复杂度 (0-1)
    NoiseLevel           float64  // 噪声水平 (0-1)
    CompressionPotential float64  // 压缩潜力 (0-1)
    ContentType          string   // photo, graphic, mixed
    QualityScore         float64  // 综合质量分数 (0-100)
}

// 基于FFprobe的精确分析
func analyzeJPEGQuality(file *MediaFile) ImageQualityMetrics {
    // 通过pix_fmt判断：
    // yuv444p  → QualityScore=98 (接近无损)
    // yuv422p  → QualityScore=80 (高质量)
    // yuv420p  → QualityScore=65 (标准质量)
}
```

**新版改进**：
- ✓ 保留FFprobe分析（精确且快速）
- ✓ 保留pix_fmt判断（关键指标）
- ✗ 简化不必要的复杂度计算
- ✓ 增加预测模型（基于历史数据）

### 核心流程重构

#### 最初版本的实际性能（实测数据）

基于PIXLY最初版本处理990个文件的实际表现：

```
总文件数：990个
├─ 高质量JPEG：320个 → 平均5秒/文件（尝试2次：无损重包装+数学无损）
├─ PNG文件：360个    → 平均7秒/文件（尝试2次：无损重包装+数学无损）
├─ 中等质量JPEG：200个 → 平均15-20秒/文件（尝试5次：2无损+3有损）
├─ GIF动画：80个     → 平均8秒/文件（直接转AVIF）
└─ 视频：30个       → 平均3秒/文件（重封装）

平均处理时间：8-10秒/文件
总处理时间：约2.5小时（990个文件）
```

**瓶颈分析**：
1. **中等质量文件最慢**：需要尝试5个质量点（90,85,75,60,55）
2. **PNG极高压缩被浪费**：97%压缩率的PNG仍走2次尝试
3. **无学习机制**：第500个文件和第1个文件处理方式完全相同

**旧流程（暴力尝试 - 最坏情况）**：
```
中等质量JPEG (500KB)
  ↓
[无损重包装] → 失败或体积增大 (5秒)
  ↓
[数学无损] → 体积减小10% (5秒)
  ↓
[质量90探测] → 生成probe文件 (3秒)
  ↓
[质量85探测] → 生成probe文件 (3秒)
  ↓
[质量75探测] → 生成probe文件 (3秒)
  ↓
[选择最佳] → 对比5个结果，选择质量85 (1秒)
  ↓
总计：20秒 ❌
```

**新流程（智能预测 - 同样文件）**：
```
中等质量JPEG (500KB)
  ↓
[特征提取] → FFprobe分析pix_fmt=yuv420p (0.1秒)
  ↓
[质量预测] → QualityScore=72，预测最优CRF=26 (0.05秒)
  ↓
[置信度评估] → 0.75（中等置信度） → 触发小范围探索
  ↓
[并行探索2-3个候选]
  ├─ CRF=26（预测值） (3秒)
  ├─ CRF=23（-3偏移） (3秒) ← 并行执行
  └─ CRF=29（+3偏移） (3秒) ← 并行执行
  ↓
[选择最佳] → CRF=26 (0.5秒)
  ↓
总计：6.5秒 ✓ (速度提升3倍)
```

**最佳情况（高置信度预测）**：
```
纯色RGBA PNG (2MB)
  ↓
[特征提取] → pix_fmt=rgba, 像素密度低 (0.1秒)
  ↓
[查找表匹配] → "png_rgba_standard" (0.01秒)
  ↓
[预测] → JXL distance=0, effort=7, 置信度=0.95 ✓
  ↓
[单次转换] → 2MB → 50KB (4秒)
  ↓
总计：4.1秒 ✓ (速度提升5倍，且100%准确)
```

---

## 🧠 智能预测算法设计

### 核心理念：从"尝试"到"预测"

#### 当前的笨拙方法

```go
// 当前：暴力枚举所有可能性
func CurrentApproach(file string) Result {
    attempts := []Quality{90, 85, 75, 60, 55}
    
    bestResult := nil
    for _, q := range attempts {
        result := TryConvert(file, q)  // 每次都实际转换！
        if result.IsBetter(bestResult) {
            bestResult = result
        }
    }
    return bestResult
}

// 问题：
// - 5次实际转换，耗时25秒
// - 浪费计算资源
// - 无学习能力
```

#### 新方法：预测模型

```go
// 新方法：基于特征预测最优参数
func PredictiveApproach(file string) Result {
    // 1. 提取文件特征（快速，0.1秒）
    features := ExtractFeatures(file)
    
    // 2. 预测最优参数（快速，0.1秒）
    params := PredictOptimalParams(features)
    
    // 3. 单次转换（仅1次，2-5秒）
    result := ConvertWithParams(file, params)
    
    // 4. 如果预测不确定，才进行探索
    if params.Confidence < 0.80 {
        result = ExploreNearbyParams(file, params)
    }
    
    return result
}

// 优势：
// - 通常只需1次转换
// - 不确定时才2-3次转换
// - 持续学习提升准确率
```

---

## 🔬 特征工程：什么决定了最优参数？

### 关键特征集

基于990个文件的实战分析，最重要的特征是：

#### 1. 格式特征（权重：40%）

```go
type FormatFeatures struct {
    OriginalFormat  string  // "png", "jpeg", "gif", "heic"
    HasAlpha        bool    // 是否有透明通道
    ColorSpace      string  // "rgb", "rgba", "grayscale"
    BitDepth        int     // 8, 16, 32
}

// 决策规则
func (f *FormatFeatures) PredictBestFormat() string {
    switch f.OriginalFormat {
    case "png":
        return "jxl"  // PNG→JXL无损，97%节省！
    case "jpeg":
        return "jxl"  // JPEG→JXL无损优先
    case "gif":
        if isAnimated {
            return "avif"  // 动态→AVIF
        }
        return "jxl"  // 静态→JXL
    case "mp4", "avi", "mkv":
        return "mov"  // 视频→MOV重封装
    }
}
```

**关键洞察**：格式本身就决定了80%的策略！

#### 2. 质量特征（权重：30%）

```go
type QualityFeatures struct {
    EstimatedQuality int     // JPEG质量估计（0-100）
    Compression      float64 // 当前压缩率
    Noise            float64 // 噪声水平
    Sharpness        float64 // 清晰度
}

// 决策规则（仅对JPEG有效）
func (q *QualityFeatures) PredictLossyNeeded() bool {
    if q.EstimatedQuality > 85 {
        return false  // 高质量→无损优先
    }
    if q.EstimatedQuality < 70 {
        return true   // 低质量→有损可接受
    }
    return "explore"  // 中等质量→需要探索
}
```

#### 3. 文件大小特征（权重：20%）

```go
type SizeFeatures struct {
    FileSize    int64   // 字节
    Width       int     // 像素
    Height      int     // 像素
    BytesPerPixel float64
}

func (s *SizeFeatures) PredictCompressionPotential() float64 {
    // PNG的关键特征
    if originalFormat == "png" {
        if s.BytesPerPixel < 0.5 {
            return 0.95  // 已高度压缩，JXL可再压95%
        }
        if s.BytesPerPixel > 3.0 {
            return 0.70  // 低压缩PNG，JXL可压70%
        }
        return 0.85  // 一般PNG，JXL可压85%
    }
    
    // JPEG的关键特征
    if originalFormat == "jpeg" {
        ratio := float64(s.FileSize) / float64(s.Width * s.Height)
        if ratio < 0.1 {
            return 0.10  // 已高度压缩，只能节省10%
        }
        if ratio > 0.5 {
            return 0.40  // 低压缩JPEG，可节省40%
        }
        return 0.20  // 一般JPEG，节省20%
    }
}
```

#### 4. 内容特征（权重：10%）

```go
type ContentFeatures struct {
    Complexity  float64  // 0-1，图像复杂度
    IsPhoto     bool     // 是否照片
    IsGraphic   bool     // 是否图形
    HasText     bool     // 是否包含文字
}

func (c *ContentFeatures) PredictOptimalEffort() int {
    if c.Complexity < 0.3 {
        return 9  // 简单图像，最高压缩effort
    }
    if c.Complexity > 0.7 {
        return 5  // 复杂图像，快速effort
    }
    return 7  // 一般图像，平衡effort
}
```

---

## 🎯 预测模型设计

### 模型1：基于规则的预测引擎（MVP）

**优势**：快速实现，可解释性强  
**适用**：80%的常见场景

```go
type RuleBasedPredictor struct {
    rules []PredictionRule
}

type PredictionRule struct {
    Name       string
    Condition  func(*FileFeatures) bool
    Prediction *ConversionParams
    Confidence float64
}

// 示例规则
var PNGRules = []PredictionRule{
    {
        Name: "PNG_RGBA_Standard",
        Condition: func(f *FileFeatures) bool {
            return f.Format == "png" && 
                   f.HasAlpha && 
                   f.Width*f.Height < 2000*2000
        },
        Prediction: &ConversionParams{
            TargetFormat: "jxl",
            Lossless: true,
            Distance: 0,
            Effort: 7,
        },
        Confidence: 0.95,  // 基于实战990个文件的数据
    },
    {
        Name: "PNG_RGB_Large",
        Condition: func(f *FileFeatures) bool {
            return f.Format == "png" && 
                   !f.HasAlpha && 
                   f.FileSize > 5*1024*1024
        },
        Prediction: &ConversionParams{
            TargetFormat: "jxl",
            Lossless: true,
            Distance: 0,
            Effort: 5,  // 大文件用较快的effort
        },
        Confidence: 0.85,
    },
    // ... 更多规则
}

func (rbp *RuleBasedPredictor) Predict(features *FileFeatures) *Prediction {
    // 遍历规则，找到第一个匹配的
    for _, rule := range rbp.rules {
        if rule.Condition(features) {
            return &Prediction{
                Params: rule.Prediction,
                Confidence: rule.Confidence,
                Method: "rule-based",
                RuleName: rule.Name,
            }
        }
    }
    
    // 没有匹配规则，返回保守的默认值
    return &Prediction{
        Params: GetConservativeDefaults(features),
        Confidence: 0.5,
        Method: "fallback",
    }
}
```

### 模型2：回归模型预测（进阶）

**优势**：基于历史数据，持续学习  
**适用**：处理复杂场景

```go
type RegressionPredictor struct {
    models map[string]*LinearModel
    kb     *KnowledgeBase
}

// 线性回归模型
type LinearModel struct {
    Weights    map[string]float64  // 特征权重
    Intercept  float64
    R2Score    float64             // 模型拟合度
    SampleSize int
}

// 训练模型
func (rp *RegressionPredictor) Train(historicalData []ConversionRecord) {
    // 按格式分组
    dataByFormat := groupByFormat(historicalData)
    
    for format, records := range dataByFormat {
        // 提取特征矩阵
        X := extractFeatureMatrix(records)
        
        // 目标变量：空间节省率
        y := extractSpaceSaving(records)
        
        // 训练线性回归
        model := trainLinearRegression(X, y)
        
        rp.models[format] = model
    }
}

// 预测空间节省率
func (rp *RegressionPredictor) PredictSaving(features *FileFeatures) float64 {
    model := rp.models[features.Format]
    if model == nil {
        return 0.20  // 默认预测20%节省
    }
    
    // 计算预测值
    prediction := model.Intercept
    for featureName, value := range features.ToVector() {
        if weight, ok := model.Weights[featureName]; ok {
            prediction += weight * value
        }
    }
    
    return prediction
}

// 基于预测的节省率，反向推导最优参数
func (rp *RegressionPredictor) PredictOptimalParams(
    features *FileFeatures,
    targetSaving float64,  // 目标节省率
) *ConversionParams {
    
    format := features.Format
    
    if format == "png" {
        // PNG永远是JXL无损（基于实战数据）
        return &ConversionParams{
            TargetFormat: "jxl",
            Lossless: true,
            Distance: 0,
            Effort: predictEffort(features.Complexity),
        }
    }
    
    if format == "jpeg" {
        predictedSaving := rp.PredictSaving(features)
        
        if predictedSaving > 0.15 {
            // 预测无损就能节省>15%
            return &ConversionParams{
                TargetFormat: "jxl",
                Lossless: true,
            }
        } else {
            // 需要有损压缩
            // 根据目标节省率，预测CRF值
            crf := predictCRFFromTargetSaving(
                targetSaving,
                features.EstimatedQuality,
            )
            return &ConversionParams{
                TargetFormat: "avif",
                Lossless: false,
                CRF: crf,
            }
        }
    }
    
    // ... 其他格式
}
```

### 模型3：查找表预测（最快）

**优势**：O(1)查找速度  
**适用**：已知模式的快速决策

```go
// 预先计算的最优参数表
var OptimalParamsTable = map[string]*ConversionParams{
    // PNG文件
    "png_small_rgba":  {Format: "jxl", Distance: 0, Effort: 7},
    "png_medium_rgba": {Format: "jxl", Distance: 0, Effort: 7},
    "png_large_rgba":  {Format: "jxl", Distance: 0, Effort: 5},
    "png_small_rgb":   {Format: "jxl", Distance: 0, Effort: 7},
    
    // JPEG文件（高质量）
    "jpeg_high_small":  {Format: "jxl", Lossless: true},
    "jpeg_high_medium": {Format: "jxl", Lossless: true},
    "jpeg_high_large":  {Format: "jxl", Lossless: true},
    
    // JPEG文件（中质量）
    "jpeg_mid_small":  {Format: "avif", CRF: 28},
    "jpeg_mid_medium": {Format: "avif", CRF: 26},
    "jpeg_mid_large":  {Format: "jxl", Distance: 1.0},
    
    // JPEG文件（低质量）
    "jpeg_low_any": {Format: "avif", CRF: 32},
    
    // GIF文件
    "gif_animated": {Format: "avif", CRF: 35},
    "gif_static":   {Format: "jxl", Distance: 0},
    
    // 视频文件
    "video_any": {Format: "mov", Repackage: true},
}

func LookupOptimalParams(features *FileFeatures) (*ConversionParams, float64) {
    key := generateKey(features)
    
    if params, ok := OptimalParamsTable[key]; ok {
        return params, 0.95  // 高置信度
    }
    
    return nil, 0
}

func generateKey(f *FileFeatures) string {
    sizeCategory := "small"
    if f.FileSize > 5*1024*1024 {
        sizeCategory = "large"
    } else if f.FileSize > 1*1024*1024 {
        sizeCategory = "medium"
    }
    
    qualityCategory := "mid"
    if f.EstimatedQuality > 85 {
        qualityCategory = "high"
    } else if f.EstimatedQuality < 70 {
        qualityCategory = "low"
    }
    
    return fmt.Sprintf("%s_%s_%s",
        f.Format,
        qualityCategory,
        sizeCategory)
}
```

---

## 🚀 新架构设计

### 核心组件（简化）

```
Pixly v3.0
│
├─ 1. Feature Extractor（特征提取器）
│    ├─ 格式检测（libmagic + exiftool）
│    ├─ 尺寸和比特深度
│    ├─ 质量估算（JPEG quality, PNG compression）
│    ├─ 复杂度分析（可选，快速估算）
│    └─ 输出：FileFeatures结构
│    
├─ 2. Parameter Predictor（参数预测器）⭐核心
│    ├─ 规则引擎（基础层）
│    ├─ 查找表（快速层）
│    ├─ 回归模型（学习层，可选）
│    └─ 输出：ConversionParams + Confidence
│    
├─ 3. Conversion Executor（转换执行器）
│    ├─ 单次转换（基于预测参数）
│    ├─ 结果验证（8层验证复用）
│    └─ 输出：ConversionResult
│    
├─ 4. Confidence Evaluator（置信度评估器）
│    ├─ 如果Confidence > 0.80 → 接受预测
│    ├─ 如果Confidence < 0.80 → 启动探索
│    └─ 输出：最终决策
│    
└─ 5. Exploration Engine（探索引擎）
     ├─ 仅在低置信度时启动
     ├─ 在预测参数附近小范围探索
     ├─ 2-3次尝试（而非5-10次）
     └─ 输出：精确的最优参数
```

### 数据流

```
输入文件
   ↓
[Feature Extractor] → FileFeatures
   ↓
[Parameter Predictor] → ConversionParams (confidence=0.95)
   ↓
[Confidence Check]
   ├─ High (>0.80) → [Conversion Executor] → 完成！ (3-6秒)
   │
   └─ Low (<0.80) → [Exploration Engine] → ConversionParams (refined)
                        ↓
                    [Conversion Executor] → 完成！ (10-15秒)
```

---

## 🔧 预测算法实现

### 算法1：PNG文件（最简单，最有效）

```go
func PredictPNGParams(features *FileFeatures) (*ConversionParams, float64) {
    // PNG的预测极其简单：总是JXL无损！
    // 基于实战数据：360个PNG，100%成功，平均节省85%
    
    effort := 7  // 默认effort
    
    // 根据文件大小调整effort
    if features.FileSize > 10*1024*1024 {
        effort = 5  // 大文件用快速effort
    } else if features.FileSize < 100*1024 {
        effort = 9  // 小文件用最高压缩
    }
    
    // 根据复杂度微调（可选）
    if features.Complexity > 0.8 {
        effort -= 1  // 复杂图像降低effort
    }
    
    return &ConversionParams{
        TargetFormat: "jxl",
        Lossless:     true,
        Distance:     0,
        Effort:       effort,
        Threads:      8,
    }, 0.95  // 95%置信度（基于实战数据）
}
```

**关键**：PNG不需要复杂预测，直接JXL无损即可！

### 算法2：JPEG文件（需要智能判断）

```go
func PredictJPEGParams(features *FileFeatures) (*ConversionParams, float64) {
    // 步骤1：估算JPEG质量
    quality := estimateJPEGQuality(features.FilePath)
    
    // 步骤2：基于质量决策
    if quality >= 85 {
        // 高质量JPEG：无损优先
        return &ConversionParams{
            TargetFormat: "jxl",
            Lossless:     true,
            LosslessJPEG: true,  // 使用JPEG无损重包装
        }, 0.90  // 高置信度
    }
    
    if quality <= 70 {
        // 低质量JPEG：有损AVIF
        // 预测CRF值（基于质量和目标节省率）
        crf := predictCRFForLowQualityJPEG(quality, features.FileSize)
        
        return &ConversionParams{
            TargetFormat: "avif",
            Lossless:     false,
            CRF:          crf,
        }, 0.80  // 中等置信度
    }
    
    // 中等质量JPEG：需要探索
    return &ConversionParams{
        // 返回一个"初始猜测"
        TargetFormat: "jxl",
        Lossless:     true,  // 先尝试无损
    }, 0.60  // 低置信度 → 将触发探索
}

// CRF预测函数
func predictCRFForLowQualityJPEG(jpegQuality int, fileSize int64) int {
    // 经验公式（基于实战数据拟合）
    baseCRF := 100 - jpegQuality  // Q70 → CRF30, Q60 → CRF40
    
    // 文件大小调整
    if fileSize > 5*1024*1024 {
        baseCRF += 3  // 大文件更激进
    }
    
    // 限制范围
    if baseCRF < 20 {
        baseCRF = 20
    }
    if baseCRF > 45 {
        baseCRF = 45
    }
    
    return baseCRF
}
```

### 算法3：GIF文件

```go
func PredictGIFParams(features *FileFeatures) (*ConversionParams, float64) {
    if features.IsAnimated {
        // 动态GIF → AVIF
        // 根据帧数预测CRF
        crf := 35  // 默认
        if features.FrameCount > 50 {
            crf = 40  // 多帧用更高CRF
        }
        
        return &ConversionParams{
            TargetFormat: "avif",
            CRF:          crf,
            FPS:          features.FrameRate,
        }, 0.85
    } else {
        // 静态GIF → 当作PNG处理
        return PredictPNGParams(features)
    }
}
```

### 算法4：视频文件（最简单）

```go
func PredictVideoParams(features *FileFeatures) (*ConversionParams, float64) {
    // 视频永远是重新封装，不重新编码
    return &ConversionParams{
        TargetFormat: "mov",
        Repackage:    true,
        CopyCodec:    true,
    }, 0.95  // 高置信度
}
```

---

## 🎨 中质量探索设计

### 何时触发探索？

```go
type ExplorationDecision struct {
    ShouldExplore bool
    Reason        string
    SearchSpace   []ConversionParams
}

func DecideExploration(
    features *FileFeatures,
    prediction *Prediction,
) *ExplorationDecision {
    
    // 触发条件1：预测置信度低
    if prediction.Confidence < 0.75 {
        return &ExplorationDecision{
            ShouldExplore: true,
            Reason: "低置信度预测",
            SearchSpace: generateNearbyParams(prediction.Params, 3),
        }
    }
    
    // 触发条件2：中等质量JPEG（最需要探索的场景）
    if features.Format == "jpeg" && 
       features.EstimatedQuality > 70 && 
       features.EstimatedQuality < 85 {
        return &ExplorationDecision{
            ShouldExplore: true,
            Reason: "中等质量JPEG需要探索无损vs有损",
            SearchSpace: []ConversionParams{
                {Format: "jxl", Lossless: true},
                {Format: "jxl", Distance: 0.5},
                {Format: "jxl", Distance: 1.0},
                {Format: "avif", CRF: 23},
                {Format: "avif", CRF: 28},
            },
        }
    }
    
    // 默认：不需要探索
    return &ExplorationDecision{
        ShouldExplore: false,
        Reason: "高置信度预测",
    }
}
```

### 智能探索策略

**不是暴力尝试所有可能，而是"聪明的小范围搜索"**：

```go
// 在预测参数附近探索
func ExploreNearbyParams(
    file string,
    predictedParams *ConversionParams,
    features *FileFeatures,
) *ConversionParams {
    
    // 定义搜索空间（仅3-5个候选）
    candidates := []ConversionParams{
        predictedParams,  // 预测值本身
    }
    
    // 根据格式生成邻近候选
    if predictedParams.TargetFormat == "jxl" {
        if predictedParams.Lossless {
            // 无损JXL，探索是否有损更好
            candidates = append(candidates,
                ConversionParams{Format: "jxl", Distance: 0.5},
                ConversionParams{Format: "jxl", Distance: 1.0},
            )
        } else {
            // 有损JXL，探索邻近distance值
            d := predictedParams.Distance
            candidates = append(candidates,
                ConversionParams{Format: "jxl", Distance: d - 0.5},
                ConversionParams{Format: "jxl", Distance: d + 0.5},
            )
        }
    }
    
    if predictedParams.TargetFormat == "avif" {
        // AVIF，探索邻近CRF值
        crf := predictedParams.CRF
        candidates = append(candidates,
            ConversionParams{Format: "avif", CRF: crf - 5},
            ConversionParams{Format: "avif", CRF: crf + 5},
        )
    }
    
    // 并发测试候选参数（最多3个同时）
    results := parallelTry(file, candidates, maxConcurrent=3)
    
    // 选择最优
    return selectBest(results, features)
}
```

---

## 📊 实现优先级

### Phase 1: MVP（2-3周）- 立即启动

**目标**：证明"预测优于尝试"的概念

#### 核心功能

1. **特征提取器（简化版）**
```go
type FileFeatures struct {
    Format          string
    FileSize        int64
    Width, Height   int
    HasAlpha        bool
    EstimatedQuality int  // 仅JPEG
    IsAnimated      bool  // 仅GIF
}

func ExtractFeatures(filePath string) (*FileFeatures, error) {
    // 使用exiftool一次性获取所有信息
    // 解析结果
    // 返回特征
}
```

2. **规则预测器**
```go
// 50-100条规则，覆盖常见场景
var PredictionRules = []Rule{
    // PNG规则（最简单）
    Rule{
        Match: "format=png",
        Params: Params{Format: "jxl", Distance: 0, Effort: 7},
        Confidence: 0.95,
    },
    
    // JPEG规则（分高/中/低质量）
    Rule{
        Match: "format=jpeg AND quality>85",
        Params: Params{Format: "jxl", Lossless: true},
        Confidence: 0.90,
    },
    
    Rule{
        Match: "format=jpeg AND quality<70",
        Params: Params{Format: "avif", CRF: 32},
        Confidence: 0.80,
    },
    
    // ... 更多规则
}
```

3. **简单的探索引擎**
```go
// 仅当置信度<0.75时触发
// 仅尝试2-3个邻近参数
func Explore(file, predictedParams, confidence) {
    if confidence > 0.75 {
        return predictedParams  // 直接使用预测
    }
    
    // 生成2-3个候选
    candidates := generateNearby(predictedParams, count=2)
    
    // 并发测试
    results := parallelConvert(file, candidates)
    
    // 选择最优
    return selectBest(results)
}
```

#### MVP交付标准

- ✓ 支持PNG、JPEG、GIF、MP4基本转换
- ✓ 90%文件直接预测（不需要探索）
- ✓ 处理速度 < 5秒/文件（平均）
- ✓ 空间节省 > 当前系统20%

### Phase 2: 增强（2-3周）

1. **知识库（基于JSON文件）**
2. **质量评估增强（SSIM/PSNR）**
3. **更多格式支持（HEIC, WebP等）**

### Phase 3: 高级（2-3周）

1. **回归模型预测**
2. **自适应参数搜索**
3. **大规模测试（10,000+文件）**

---

## 🎯 关键决策表

### 格式决策矩阵（核心）

| 原始格式 | 条件 | 目标格式 | 参数 | 置信度 | 预期节省 |
|---------|------|---------|------|--------|---------|
| **PNG** | 任何 | **JXL** | distance=0, effort=7 | 0.95 | 70-98% |
| **JPEG** | Q>85 | **JXL** | lossless=true | 0.90 | 10-30% |
| **JPEG** | 70<Q<85 | **探索** | 无损 vs 有损 | 0.60 | 需探测 |
| **JPEG** | Q<70 | **AVIF** | CRF=32-40 | 0.80 | 30-60% |
| **GIF** | 动画 | **AVIF** | CRF=35 | 0.85 | 70-95% |
| **GIF** | 静态 | **JXL** | distance=0 | 0.90 | 50-90% |
| **MP4** | 任何 | **MOV** | repackage | 0.95 | 0-5% |

**关键理解**：
- 80%的文件可以直接预测（PNG, 高/低质量JPEG, GIF, 视频）
- 20%的文件需要探索（中等质量JPEG）

---

## 🚧 实现建议

### 建议1：继承最初版本的优点

**从PIXLY最初版本保留的代码**：

```go
// ✓ 保留：FFprobe质量分析（已验证有效）
func analyzeJPEGQuality(file *MediaFile) ImageQualityMetrics {
    args := []string{"-v", "quiet", "-print_format", "json", 
                     "-show_streams", file.Path}
    cmd := exec.Command(ffprobePath, args...)
    output, _ := cmd.Output()
    
    // 解析pix_fmt字段
    switch stream.PixFmt {
    case "yuv444p":  return 98  // 无损质量
    case "yuv422p":  return 80  // 高质量
    case "yuv420p":  return 65  // 标准质量
    }
}

// ✓ 保留：格式决策逻辑
func selectTargetFormat(file *MediaFile) string {
    if isAnimated(file) {
        return "avif"  // 动画永远是AVIF
    }
    if isPNG(file) || isJPEG(file) {
        return "jxl"   // 静态图永远是JXL
    }
    if isVideo(file) {
        return "mov"   // 视频重封装为MOV
    }
}

// ✓ 保留：探测结果选择逻辑
func selectBestProbeResult(results []ProbeResult, originalSize int64) *ProbeResult {
    const minSizeReduction = 1024  // 1KB
    const minReductionRatio = 0.05 // 5%
    
    compressionWeight := 0.7
    qualityWeight := 0.3
    
    score := compressionWeight*reductionRatio + qualityWeight*(quality/100.0)
    return bestScoreResult
}
```

**从最初版本删除的代码**：

```go
// ❌ 删除：Quality模式和Emoji模式
type ConversionMode int
const (
    ModeQuality  // 删除，合并到Auto+的高质量路径
    ModeEmoji    // 删除，合并到Auto+的低质量路径
)

// ❌ 删除：冗余的质量分类
func analyzeImageQuality(file *MediaFile) string {
    // 分类太复杂：极高/高品质/原画/中高/中低/中等/极低/低品质
    // 简化为：直接使用QualityScore数值（0-100）
}

// ❌ 删除：性能优化器的过度复杂监控
type PerformanceOptimizer struct {
    // 删除：网络监控（与媒体转换无关）
    NetworkSentBytes uint64
    NetworkRecvBytes uint64
    
    // 删除：磁盘IOPS监控（太细粒度）
    DiskIOPS float64
    
    // 保留：内存和CPU监控（关键指标）
    MemoryUsage float64
    CPUUsage    float64
}
```

### 建议2：从PNG开始实施（实战验证）

**原因**（基于990文件实战数据）：
- PNG→JXL的策略最简单（总是distance=0）
- 但效果最显著（平均85%节省，最高97%）
- **360个PNG文件，100%成功，0失败**
- 快速验证新架构设计

**MVP实施步骤**：

```go
// Week 1: PNG专用预测器（2-3天）
type PNGPredictor struct{}

func (p *PNGPredictor) Predict(file *MediaFile) (*Params, float64) {
    // 极其简单的预测逻辑
    effort := 7  // 默认
    if file.Size > 10*MB {
        effort = 5  // 大文件快速处理
    }
    
    return &Params{
        Format: "jxl",
        Distance: 0,
        Effort: effort,
    }, 0.95  // 95%置信度
}

// 测试：100个PNG文件
// 预期：平均4秒/文件（vs 最初版本7秒）
// 预期：100%成功率，85%+压缩率
```

### 建议3：重构而非新建

**不要**：创建全新的代码库  
**应该**：在PIXLY最初版本基础上渐进重构

**重构路线图**：

```
Phase 1: 特征提取层（新增）
  ├─ feature_extractor.go （新文件）
  └─ 复用最初版本的FFprobe调用

Phase 2: 预测引擎（新增）
  ├─ predictor.go （新文件）
  │  ├─ RuleBasedPredictor
  │  └─ LookupTablePredictor
  └─ 复用最初版本的格式判断逻辑

Phase 3: 简化strategy.go（重构）
  ├─ 删除Quality/Emoji策略
  ├─ 保留AutoPlus策略
  └─ 替换applyBalancedOptimization内部实现
      旧：5次尝试 → 新：预测+探索

Phase 4: 删除冗余（清理）
  ├─ 删除performance_optimizer.go的过度监控
  ├─ 简化image.go的质量分析
  └─ 保留converter.go核心转换逻辑
```

**关键：渐进式，每个阶段都可独立测试**

### 建议4：实施时间线（6-9周）

**Week 1-2 (MVP - PNG专项)**: 
- 实现PNG特征提取器
- 实现PNG规则预测器
- 重构strategy.go中PNG处理逻辑
- 测试500个PNG文件
- **成功标准**：速度提升2倍，100%成功率

**Week 3-4 (扩展 - JPEG高质量)**:
- 添加JPEG质量分析（复用最初版本的FFprobe逻辑）
- 实现高质量JPEG预测（yuv444p→无损，yuv420p→探索）
- 测试500个JPEG文件
- **成功标准**：高质量JPEG直接预测，中等质量2-3次探索

**Week 5-6 (完善 - 全格式支持)**:
- 添加GIF/WebP动静图检测（复用最初版本）
- 添加视频重封装逻辑（复用最初版本）
- 测试1000+个混合格式文件
- **成功标准**：平均处理时间<5秒/文件

**Week 7-8 (优化 - 知识库与学习)**:
- 实现转换历史记录（JSON格式）
- 实现回归预测器（可选）
- 大规模测试（5000+文件）
- **成功标准**：预测准确率>85%

**Week 9 (文档与发布)**:
- 更新所有文档
- 性能对比报告
- 迁移指南（从v1.0到v3.0）
- **交付**：完整的v3.0版本

### 建议5：复用现有测试集

**PIXLY最初版本的TESTPACK**（已验证的测试集）：

```
TESTPACK PASSIFYOUCAN!/
├─ 🆕 Avif动图和表情包测试使用/
│  └─ 18个GIF动图 → 必须转为AVIF
├─ 🆕测试不同格式的媒体/
│  ├─ 4个AVIF
│  ├─ 2个PNG
│  ├─ 2个WebP
│  └─ 其他格式
└─ 🆕测试大量转换和嵌套文件夹/
   └─ 未命名相簿/
      ├─ 855个JPEG
      ├─ 51个PNG
      └─ 48个GIF

测试要求（来自原版要求）：
1. ✓ 静态图片必须转为JXL
2. ✓ 动态图片必须转为AVIF
3. ✓ 必须正确识别静动图
4. ✓ 100%成功转换或正确跳过
```

**新版v3.0必须通过相同的测试集**，确保不退步！

---

## 🎊 总结

**项目简化**：
- 删除Quality, Emoji, Sticker模式
- 只保留Auto+（智能模式）
- 聚焦核心：**预测 > 尝试**

**核心算法**：
- 从"暴力枚举5-10次"
- 到"智能预测1次，低置信度时探索2-3次"
- 速度提升：3-5倍

**关键洞察应用**：
- PNG→JXL无损：直接预测（置信度0.95）
- JPEG：基于质量智能决策
- GIF/视频：规则直接决策

**下一步**：
- 开始重构`balance_optimizer.go`
- 实现特征提取器
- 实现规则预测引擎

**准备开始实施吗？** 🚀

